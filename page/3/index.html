<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rudy&#39;s blog</title>

<meta name="description" content="">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />
<link rel="alternate" type="application/rss+xml" href="https://rudychow.github.io/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Rudy&#39;s blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://rudychow.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rudy&#39;s blog"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Rudy's blog",
  "url": "https://rudychow.github.io/",
  "description": "",
  "thumbnailUrl": "https://rudychow.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：rdb
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 有两种数据持久化策略，其中一种是RDB（Redis database），属于快照持久化的方式。它分为主动备份和定时备份两种方式去运行。
主动备份 当执行save或者bgsave时，Redis 就会进行一次RDB的持久化。如果数据量比较大的情况下，执行save是一个比较耗时的动作，所以会阻塞客户端。bgsave可以又称作background save，用来解决save阻塞的情况，此时会fork出一个子进程来执行save命令。
save 先看save对应的saveCommand源码：
void saveCommand(client *c) { if (server.rdb_child_pid != -1) { addReplyError(c,&#34;Background save already in progress&#34;); return; } rdbSaveInfo rsi, *rsiptr; rsiptr = rdbPopulateSaveInfo(&amp;rsi); if (rdbSave(server.rdb_filename,rsiptr) == C_OK) { addReply(c,shared.ok); } else { addReply(c,shared.err); } } rdbPopulateSaveInfo主要是 Redis 复制的一些预处理，由于尚未看复制相关的代码，所以这次暂时不展开。
rdbSave则是 Redis 实现RDB持久化的主要函数，这里 Redis 会调用自己封装的 io 操作库 rio 来写入数据。
bgsave bgsave对应的bgsaveCommand源码：
void bgsaveCommand(client *c) { int schedule = 0; /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite * is in progress....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-31 20:40:57 +0800 HKT'>October 31, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：rdb" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81rdb/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：事务
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 与事务相关的命令有：multi、discard、exec和watch。
multi、discard和exec这是一组命令，与MySQL的begin、rollback和commit有相似之处。watch则是监听某个键，如果键值发生了改编，在事务中则会更新客户端的状态。
数据结构 // 事务状态 typedef struct multiState { multiCmd *commands; /* 命令数组，元素是没一个事务中需要执行的命令，以先进先出的顺序保存 */ int count; /* 一共有多少个待处理的命令 */ int cmd_flags; /* The accumulated command flags OR-ed together. So if at least a command has a given flag, it will be set in this field. */ int minreplicas; /* MINREPLICAS for synchronous replication */ time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */ } multiState; // watch的信息 typedef struct watchedKey { robj *key; redisDb *db; } watchedKey; // 客户端相关的事务字段 typedef struct client { multiState mstate; /* 事务状态 */ list *watched_keys; /* watch的key，里面每个元素都是watchedKey结构体变量 */ } client; // db typedef struct redisDb { dict *watched_keys; /* watch的key，键是key，值是客户端链表 */ } redisDb; 状态 与事务相关的几个客户端状态有：...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-30 18:39:35 +0800 HKT'>October 30, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：事务" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%BA%8B%E5%8A%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：pub和sub
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 中使用订阅与发布同样可以达到 block 的效果。
数据结构 客户端：
typedef struct client { dict *pubsub_channels; /* 普通订阅，key是channel，value为null */ list *pubsub_patterns; /* 匹配模式的订阅*/ } client; 服务端：
struct redisServer { dict *pubsub_channels; /* 普通订阅，key是channel，value为客户端链表 */ list *pubsub_patterns; /* 匹配模式的订阅 */ }; 订阅 通过subscribeCommand中可以定位到订阅的源码，这里会对订阅的每个channel都调用pubsubSubscribeChannel，并且把客户端状态叠加订阅发布状态。
server.pubsub_channels是字典，键是频道，值是客户端链表。pubsubSubscribeChannel最主要工作就是往server.pubsub_channels的频道客户端链表里添加当前客户端。
发布 publishCommand是发布对应的函数，里面会调用pubsubPublishMessage进行消息推送。
函数里最主要做的就是，在server.pubsub_channels中寻找对应的频道，并且循环客户端链表，给每个客户端发送消息。然后会在server.pubsub_patterns中寻找匹配规则的客户端发送消息。
与block的不同 发布订阅的功能虽然可以实现block的功能，但是两者之间还是有区别：
 发布是群发消息，而 block 是先进先出，即 pop 操作。 发布订阅不区分 db，channel 是作用于整个 server。而 block 是作用于 db。 发布订阅没有超时时间限制，block 有超时限制。 发布订阅支持匹配模式  </p>
  </section>
  <footer class="entry-footer"><span title='2020-10-28 23:52:02 +0800 HKT'>October 28, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：pub和sub" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81pub%E5%92%8Csub/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：从bpop看block
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 中可以通过brpop、blpop和brpoplpush来实现对列表的阻塞 pop 操作。
Redis 在处理主逻辑是单线程的，如果使用上述的命令进行阻塞操作的话，后面的请求也会一并阻塞。但是实际场景下，这几个命令并不会造成其它客户端阻塞，所以这里会从源码角度看看 Redis 怎么实现这些功能的。
阻塞状态 首先从redisCommandTable中找到brpop的命令入口以及整个调用链：brpopCommand-&gt;blockingPopGenericCommand-&gt;blockForKeys。
brpopCommand里只会调用blockingPopGenericCommand，blockingPopGenericCommand则会判断目标列表是否有元素，如果有，则直接返回，如果列表为空或者不存在该键，则调用blockForKeys。
在看blockForKeys函数前需要先看几个关于 block 的结构体和属性（省略部分属性）：
// 阻塞的几种类型 #define BLOCKED_NONE 0 /* Not blocked, no CLIENT_BLOCKED flag set. */#define BLOCKED_LIST 1 /* BLPOP &amp; co. */#define BLOCKED_WAIT 2 /* WAIT for synchronous replication. */#define BLOCKED_MODULE 3 /* Blocked by a loadable module. */#define BLOCKED_STREAM 4 /* XREAD. */#define BLOCKED_ZSET 5 /* BZPOP et al. */ // block info typedef struct bkinfo { listNode *listnode; /* List node for db-&gt;blocking_keys[key] list....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-26 23:48:25 +0800 HKT'>October 26, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：从bpop看block" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%BB%8Ebpop%E7%9C%8Bblock/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：一个命令的执行流程
    </h2>
  </header>
  <section class="entry-content">
    <p>一个命令的执行过程，我们大概可以分成三步骤：建立连接，发送命令，得到结果。下面会针对这三个命令，结合源码进行分析：
  建立连接
建立连接要从acceptTcpHandler这个函数说起。
前面说过，Redis 初始化服务时，会创建一个事件循环eventLoop。在 Redis 监听端口时，会给对应的 socket 绑定一个文件事件，且该事件的回调函数就是acceptTcpHandler。也就是说，任何连接到这个端口的客户端，Redis 都会调用acceptTcpHandler这个函数。
刚初始化后，等待客户端连接时的eventLoop（此处 fd 假设为 0）：
回调函数的整个调用链：acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient。
简单说明一下acceptTcpHandler的代码逻辑：Redis 最多会循环 1000 次accept客户端来得到对应的客户端 fd，并且每一次循环中会调用acceptCommonHandler函数。所以我们的目标转移到acceptCommonHandler函数上。
acceptCommonHandler的代码也很简单，最重要的是就是调用createClient函数，其余都是一些边界条件判断以及数据状态更新。
createClient做了什么？注册对应客户端 fd 的可读事件函数readQueryFromClient以及初始化client对象并且 push 到server的客户端链表里。
连接创建后的事件循环：
  发送命令
与客户端建立连接后，事件循环中就多了一个对应的文件描述符的读事件。只要客户端发送数据，在 Redis 进入到事件循环中就会调用对应事件的回调函数readQueryFromClient。
首先简述一下发送命令的调用链：readQueryFromClient-&gt;processInputBufferAndReplicate-&gt;processInputBuffer-&gt;processCommand-&gt;call。
  readQueryFromClient
这是 Redis 接受客户端请求后的回调函数，主要的逻辑就是读取 client 的 fd 的数据，并且存入 client 的 querybuf 变量中，然后调用processInputBufferAndReplicate。
  processInputBufferAndReplicate
因为客户端有可能用于主从节点，这一步其实就是对第三步的封装。主要是进行 client 类型的判断，如果是普通 client 就直接调用processInputBuffer。
  processInputBuffer
这一步是解析客户端的输入流中的 RESP 协议，转换成 Redis 中对应的参数，即 client 的 argv 变量。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-15 11:23:53 +0800 HKT'>October 15, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：一个命令的执行流程" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：redisDB
    </h2>
  </header>
  <section class="entry-content">
    <p>redisDB 即是 database，是 Redis 的数据库。它是变量server里的一个成员变量数组，数组大小默认是 16。
客户端默认使用第一个数据库，其间可以使用select进行 db 的切换。
初始化 db 的初始化是在initServer中进行。
// 分配空间 server.db = zmalloc(sizeof(redisDb)*server.dbnum); // 遍历数组，并且初始化每个变量 for (j = 0; j &lt; server.dbnum; j&#43;&#43;) { server.db[j].dict = dictCreate(&amp;dbDictType,NULL); server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL); server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,NULL); server.db[j].ready_keys = dictCreate(&amp;objectKeyPointerValueDictType,NULL); server.db[j].watched_keys = dictCreate(&amp;keylistDictType,NULL); server.db[j].id = j; server.db[j].avg_ttl = 0; server.db[j].defrag_later = listCreate(); } 数据结构 对应的结构体如下：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-14 22:22:47 +0800 HKT'>October 14, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：redisDB" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81redisdb/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：入口函数main
    </h2>
  </header>
  <section class="entry-content">
    <p>main 函数是程序执行的起点，也是大家就阅读源码的入口。要了解 Redis 的初始化和运行过程，还是要通过 main 函数入手。
已一个单机的 Redis 为例，main 函数主要可以分成以下几个步骤：
  初始化配置
Redis 中有个非常重要的全局变量server，初始化配置就是针对这个变量进行的。
Redis 会先根据initServerConfig来进行默认配置的初始化。如果启动 server 时指定了配置文件，则会调用loadServerConfig来加载配置文件中的配置。
  初始化服务
initServer会进行一些服务的初始化，包括：信号捕获、创建共享对象、调整文件描述符限制、创建事件循环对象、初始化 db等等。
  初始化后台线程
通过InitServerLast函数进行，具体逻辑可以参考之前 bio 的文章。
  加载持久化数据
通过loadDataFromDisk函数进行数据加载，优先加载 AOF，如果没有开启 AOF 则加载 RDB。
  事件循环
通过aeMain来进行事件循环。
这个在之前的文件事件循环和时间事件循环中有提到过，没有提及两个前后置的函数：beforeSleep和afterSleep，这里进行一下补充
  beforeSleep
beforeSleep是在每次事件循环开始就会执行。
主要逻辑：
 集群的clusterBeforeSleep 进行一次过期 key 的快速清除 AOF 操作 注册可写的客户端的写事件  等等…
  afterSleep
需要注意的是，afterSleep的处理时机是在执行完aeApiPoll后，而不是处理完所有待处理的文件事件和时间事件后。
afterSleep主要涉及到 module，这部分代码尚未阅读。
    </p>
  </section>
  <footer class="entry-footer"><span title='2020-10-14 15:03:38 +0800 HKT'>October 14, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：入口函数main" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0main/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：bio
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。
初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。
实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：
// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-12 16:39:29 +0800 HKT'>October 12, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：bio" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：object
    </h2>
  </header>
  <section class="entry-content">
    <p>我们经常使用 Redis 的基础命令有string、set、list、hashtable和zset。在 Redis 的底层中，我们不是直接使用它们对应的数据结构，而是通过 object 对这些基础命令进行封装后再对外使用。
数据结构 typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; } robj;   type和encoding
type 是指对象记录的类型，分别对应着string、set、list、hashtable和zset。encoding 则表示编码，代表对应 type 的底层实现方式。
  ptr
这个是指向底层实现的数据结构的指针。
  refcount
引用计数，一个 object 可以被多个地方所使用。当被引用时，refcount 会 &#43;1，变成 0 时会被销毁。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-11 12:25:01 +0800 HKT'>October 11, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：object" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81object/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：skiplist
    </h2>
  </header>
  <section class="entry-content">
    <p>skiplist 是 Redis 对于跳跃表的一个实现，它也是 zset 的主要实现。网上关于 skiplist 数据结构的介绍有很多，这里主要记录 Redis 中的实现方式。
数据结构 // 跳表节点 typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[]; } zskiplistNode; // 跳表 typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length;// 有多少个节点  int level;// 目前有几层高 } zskiplist; skiplist 简单点说就是个有序的双向链表，同时为了提高查询复杂度，增加了层的概念，其实是一种空间换时间的方法。
与 adlist 这种传统的双向链表来比较，skiplist 的前节点指针跟 adlist 的*prev的用法一样，但是后节点的指针*next却不同。
skiplist 中指向后节点的指针是使用层来存储。层在代码中就是一个数组，在最底层level[0]中永远会指向下一个节点。如果只想把 skiplist 当作一个普通的双向链表来使用，那么通过 zskiplistNode 中的*backward以及level[0]....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-08 12:13:32 +0800 HKT'>October 8, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：skiplist" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81skiplist/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://rudychow.github.io/page/2/">« Prev Page</a>
    <a class="next" href="https://rudychow.github.io/page/4/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
