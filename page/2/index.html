<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rudy&#39;s blog</title>

<meta name="description" content="">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />
<link rel="alternate" type="application/rss+xml" href="https://rudychow.github.io/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Rudy&#39;s blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://rudychow.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rudy&#39;s blog"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Rudy's blog",
  "url": "https://rudychow.github.io/",
  "description": "",
  "thumbnailUrl": "https://rudychow.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Vscode下使用GDB调试Redis
    </h2>
  </header>
  <section class="entry-content">
    <p> 配置.vscode/launch.json：  { &#34;version&#34;: &#34;0.2.0&#34;, &#34;configurations&#34;: [ { &#34;name&#34;: &#34;redis启动&#34;, &#34;type&#34;: &#34;cppdbg&#34;, &#34;request&#34;: &#34;launch&#34;, &#34;program&#34;: &#34;${workspaceFolder}/src/redis-server&#34;, &#34;args&#34;: [&#34;${workspaceFolder}/redis.conf&#34;], &#34;stopAtEntry&#34;: false, &#34;cwd&#34;: &#34;${workspaceFolder}&#34;, &#34;environment&#34;: [], &#34;externalConsole&#34;: false, &#34;MIMode&#34;: &#34;gdb&#34;, &#34;preLaunchTask&#34;: &#34;make redis&#34;, &#34;setupCommands&#34;: [ { &#34;description&#34;: &#34;为 gdb 启用整齐打印&#34;, &#34;text&#34;: &#34;-enable-pretty-printing&#34;, &#34;ignoreFailures&#34;: true } ] } ] } 配置.vscode/tasks.json：  { &#34;version&#34;: &#34;2.0.0&#34;, &#34;tasks&#34;: [ { &#34;label&#34;: &#34;make redis&#34;, &#34;type&#34;: &#34;shell&#34;, &#34;command&#34;: &#34;make&#34;, &#34;args&#34;: [ &#34;CFLAGS=\&#34;-g -O0\&#34;&#34; ], &#34;options&#34;: { &#34;cwd&#34;: &#34;${workspaceFolder}/src&#34; } } ] } Start Debugging  </p>
  </section>
  <footer class="entry-footer"><span title='2020-12-13 13:45:54 +0800 HKT'>December 13, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Vscode下使用GDB调试Redis" href="https://rudychow.github.io/post/redis/vscode%E4%B8%8B%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95redis/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>InnoDB存储结构
    </h2>
  </header>
  <section class="entry-content">
    <p>从 InnoDB 存储引擎的逻辑存储结构看，所有数据都被逻辑地存在一个空间中，称为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。
这一部分内容基本都是讲存储结构的，所以用自己语言简单总结一下，避免以后看不懂。
  表空间是什么？
InnoDB 相关的数据总得有个地方存。表空间说白了就是存储 InnoDB 相关的文件，包括且不限于数据、索引、undo信息。
默认有一个共享表空间，即ibdata1。如果开启了参数innodb_file_per_table，则每个表会有自己独立的存储文件，文件是表名.ibd。
  页是什么？
说到 MySQL 一定会谈到 B&#43; 树，谈到 B&#43; 树又一定会谈到页。页说白了就是一个连续的空间，默认是 16KB。
我们知道数据是存储在页里面，所以这个页叫数据页。页是 InnoDB 操作数据的最小单位，它不单指只有数据页这种类型，还有许多其它类型：
 B&#43; 树叶节点 undo log 页 索引节点 新分配未使用 系统页 Insert Buffer Bitmap …  而在表空间里，其实就是由许许多多的页构成，从代码上看大概是这样：
type page struct{} func main() { // 表空间里面有许许多多页组成 	// 每个表空间一定会有三个页 	// 系统表空间也会预先分配一定的空间 	tablespace := make([]page, 3, 64) // 第一个页是系统页 	fmt.Println(tablespace[0]) // 第二个页是insert buffer bitmap页 	fmt....</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-08 23:09:35 +0800 HKT'>December 8, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to InnoDB存储结构" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>redo日志
    </h2>
  </header>
  <section class="entry-content">
    <p>结合最近的学习总结一下 redo log 相关的知识，以及回答之前的困惑。
redo log 与 bin log 这两个日志是我之前经常迷惑的地方，因为两者在不同层面上都能实现恢复数据的效果。
要了解两者的区别，首先要知道这两个日志分别是什么。
redo log 是基于 InnoDB 存储引擎的一个日志，它是用来保证数据持久性的一个日志，并且记录的是物理日志，例如一个 DML 的 SQL 语句导致表空间的某几个页的某个位置。除此之外，redo log 的日志并不会长期保存，而是会进行循环覆盖，这个跟 Checkpoint 机制有关。
bin log 是 MySQL Server 层面的一个日志，意思是不管什么存储引擎，MySQL 都可以进行 bin log 的日志。bin log 默认不开启，并且记录的是逻辑日志，即具体的 SQL 语句（ROW和MIXED格式的则不一定）。bin log 的日志会不停增长，它常常用于复制数据。
那么 redo log 和 bin log 是怎么保持两边数据的一致性呢？两边是通过两阶段提交（2PC）来解决两个日志之间数据不一致的问题。通过配置参数innodb_support_xa来开启 XA 事务。MySQL 8 之后废弃了该参数，默认开启 XA。
流程是：
 当事务提交时 InnoDB 存储引擎进行 prepare 操作。 MySQL 数据库上层写入 bin log。 InnoDB 存储引擎将日志写入 redo log。  修改内存中事务对应的信息，并且将日志写入 redo buffer cache。 调用 fsync 将确保日志都从 redo buffer cache 写入磁盘。    在做 Carash Recovery 时：...</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-06 11:57:57 +0800 HKT'>December 6, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to redo日志" href="https://rudychow.github.io/post/mysql/redo%E6%97%A5%E5%BF%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：文件
    </h2>
  </header>
  <section class="entry-content">
    <p>这一章节重点在 bin log 以及 InnoDB 存储引擎文件。
参数文件 MySQL 实例启动时，会先读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，用户可以通过怕命令mysql --help| grep my.cnf来寻找即可。
MySQL 实例可以不需要参数文件，这时所有的参数值取决于编译 MySQL 时指定的默认值和源代码中指定参数的默认值。推荐使用命令SHOW VARIABLES来查看数据库中的所有参数，也可以通过 LIKE 来过滤参数名。
参数可以分成两类：动态参数和静态参数。
动态参数意味着可以在 MySQL 实例运行中进行更改，静态参数说明在整个实例生命周期内都不得进行更改。
可以通过 SET 命令对动态参数值修改，语法：SET [global | session] system_var_name = expr。
global 和 session 表明参数修改是基于当前会话还是整个实例。有些动态参数只能在会话中进行修改，如autocommit；而有些参数修改完后，在整个实例生命周期都会生效，如binlog_cache_size；而有些参数既可以在会话中也可以在实例中生效，如read_buffer_size。
日志文件 错误日志 错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令SHOW VARIABLES LIKE &#39;log_error&#39;来定位该文件。
慢查询日志 慢日志可以帮助 DBA 定位可能存在问题的 SQL 语句，从而进行 SQL 语句层面的优化。可以通过参数log_query_time（单位微秒）来设置慢查询日志的阈值。
另一个和慢查询日志有关的参数是log_queries_not_using_indexes，如果运行的 SQL 语句没有使用索引，MySQL 数据库同样会将这条 SQL 语句记录到慢查询日志文件。
MySQL 5.6.5 版本开始新增了一个参数log_throttle_queries_not_using_indexes，用来表示每分钟允许记录到 slow log 的且未使用索引的 SQL 语句次数。该值默认为 0，表示没有限制。
MySQL 数据库提供了mysqldumpslow命令，可以帮助 DBA 更直观分析 slow log。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-05 19:04:43 +0800 HKT'>December 5, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：文件" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：InnoDB存储引擎
    </h2>
  </header>
  <section class="entry-content">
    <p>这一章节随便拿出一小节都可以单独写一篇文章，这里仅做笔记和总结。
体系架构 后台线程 InnoDB 存储引擎是多线程的模型，因此后台有多个不同的后台线程，负责处理不同的任务。
Master Thread Master Thread 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO 页的回收等。
IO Thread 在 InnoDB 存储引擎中大量使用了 AIO 来处理写 IO 请求，这样可以极大提高数据库的性能，IO Thread 的工作主要是负责这些 IO 请求的回调处理。
InnoDB 1.0 版本之前共有 4 个 IO Thread，分别是 write、read、insert buffer 和 log IO thread。
Purge Thread 事务被提交后，所使用的 undolog 可能不再需要，因此需要 Purge Thread 来回收已经使用并分配的 undo 页。在 InnoDB 1.1 版本之前，purge 操作仅在 Master Thread 中完成。而在 InnoDB 1.1 版本开始，purge 操作可以独立到单独的线程中进行，以此来减轻 Master Thread 的工作，从而提高 CPU 的利用率以及提升存储引擎的性能。
用可可以在 MySQL 数据库的配置文件中添加如下命令来启用独立的 Pruge Thread：
[mysqld] innodb_purge_threads=1 Page Cleaner Thread Page Cleaner Thread 实在 InnoDB 1....</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-04 22:23:00 +0800 HKT'>December 4, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：InnoDB存储引擎" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：MySQL体系结构和存储引擎
    </h2>
  </header>
  <section class="entry-content">
    <p>这一节主要是一些基础概念和介绍，所以此处只进行了基本的笔记总结。
数据库与实例 数据库：物理操作系统文件或其他形式文件类型的集合。
实例：MySQL 数据库由后台线程以及一个共享内存区组成。MySQL 数据库实例在系统上的表现就是一个进程。
配置 当启动实例时，MySQL 数据库会按/etc/my.cnf-&gt;/etc/mysql/my.cnf-&gt;/usr/local/mysql/etc/my.cnf-&gt;~/.my.cnf去读取配置文件，并且以读取到的最后一个配置文件中的参数为准。
配置文件中有一个参数datadir，该参数指定了数据库所在的路径。在 Linux 操作系统下默认datadir为/usr/local/mysql/data。
连接方式  TCP/IP 命名管道 UNIX 域套接字  存储引擎 MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。需要注意，存储引擎基于表，而不是数据库。
MyISAM MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP 数据库应用。MyISAM 存储引擎有两个与众不同的地方：
 不支持事务，因为并非所有的应用中都需要事务。 它的缓冲池只缓存索引文件，而不缓冲数据文件。  MyISAM 存储引擎表由 MYD 和 MYI 组成，MYD 用来存放数据文件，MYI 用来存放索引文件。
Memory Memory 存储引擎将表中的数据存放在内存中，如果数据库重启或者发生崩溃，表中的数据都将消失。Memory 存储引擎默认使用哈希索引，而不是我们熟悉的 B&#43;树索引。
Memory 存储引擎在使用上有一定限制，比如，只支持表锁，并发性能较差，并且不支持 TEXT 和 BLOB 列类型。MySQL 数据库使用 Memory 存储引擎作为临时表来存放查询的中间结果集。如果中间结果集大于 Memory 存储引擎的容量设置，又或者中间结果含有 TEXT 或 BLOB 列类型字段，则 MySQL 数据库会把其转换到 MyISAM 存储引擎表而存放到磁盘中。之前提到 MyISAM 不缓存数据文件，因为这时产生的临时表的性能对于查询会有损失。
InnoDB InnoDB 存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于 Oracle 的非锁定读，即默认读取操作不会产生锁。从 MySQL 数据库 5....</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-04 18:02:36 +0800 HKT'>December 4, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：MySQL体系结构和存储引擎" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码阅读阶段总结
    </h2>
  </header>
  <section class="entry-content">
    <p>把 Redis 分成几个部分来阅读，目前的阅读情况：
多机：
 集群 复制 哨兵  单机：
 ae db  持久化：
 AOF RDB  数据结构：
 SDS ZIPLIST INISET ADLIST SKIPLIST DICT QUICKLIST GEO OBJECT BITMAP HYPERLOGLOG  其它功能：
 BLOCK PUBSUB BIO EVICT SLOWLOG 事务 LUA  Redis6：
 多线程 ACL TLS  作为非 C 程序员，第一次看关于 C 的项目源码，没有想象中吃力。
Redis 的项目结构非常清晰简单，比如 ae 功能，对应就是一个ae.h头文件和ae.c源文件，加上ae_*.c其它相关的文件。只要看一下这些文件的 API，并且搜索一下这些 API 在整个运行流程中的调用位置，就大概可以了解这个功能。
项目的注释也非常齐全，在一些比较复杂或者逻辑比较多的函数，都会有大段的注释，阅读起来非常方便。
虽然是用 C 写的项目，但是大部分都觉得非常得面向对象。比如服务器，即是一个全局的redisServer结构体变量，每个客户端就是一个client结构体变量，并且用了很多函数指针，使用起来和对象没什么区别。
后面有时间会把其余的功能也阅读一遍。</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-16 06:21:00 +0800 HKT'>November 16, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码阅读阶段总结" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：多线程
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis6 有了不少更新：ACL 权限、RESP3 协议、SSL等等，其中包括了多线程。
以往的 Redis 在处理网络 IO 时是单线程，在新版本中引入了多线程。默认是关闭的，需要修改配置进行开启。
相关配置与变量 有两个配置参数会影响到多线程：
// 线程数量，默认是1，即只有主线程，最大是128 io-threads [1~128] // 是否通过辅助线程来读取并解析客户端，默认是0 io-threads-do-reads [0|1] 还有几个相关的结构体字段以及全局变量：
struct redisServer { int io_threads_num; /* Number of IO threads to use. */ int io_threads_do_reads; /* Read and parse from IO threads? */ int io_threads_active; /* Is IO threads currently active? */ }; // 多线程目前需要进行的操作开关，有IO_THREADS_OP_WRITE和IO_THREADS_OP_READ int io_threads_op; // 下标是线程id，值是客户端链表 list *io_threads_list[IO_THREADS_MAX_NUM]; // 下标是线程id，值是需要处理的客户端数量，该变量具有原子性 _Atomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM]; 开启多线程 多线程的开启在src/server.c中的InitServerLast中。以往该函数负责开启bio，新版本中还会调用initThreadedIO来开启多线程。
initThreadedIO的逻辑很简单，这里会循环server.io_threads_num去初始化io_threads_list变量，并且创建server.io_threads_num-1个数量的线程。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-15 16:31:01 +0800 HKT'>November 15, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：多线程" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：内存淘汰策略
    </h2>
  </header>
  <section class="entry-content">
    <p>当 Redis 的内存达到一定值时，会触发自身的内存淘汰策略，目的是为了避免内存的增长。Redis 内存相关的淘汰策略代码主要在src/evict.c里。
相关配置 配置文件中的maxmemory和maxmemory-policy就可以对 Redis 进行淘汰策略的配置。
  maxmemory
Redis 可用的最大内存，也就是触发策略的阈值。32 位系统下默认是 3G 内存（受限于 4G 内存空间），64 位系统下不受限制。
  maxmemory-policy
相关的策略，一共有：
 volatile-lru：过期键 LRU 策略。 volatile-lfu：过期键 LFU 策略。 volatile-random：过期键 RANDOM 策略。 volatile-ttl：过期键 TTL 策略。 allkeys-lru：所有键 LRU 策略。 allkeys-lfu：所有键 LFU 策略。 allkeys-random：所有键 RANDOM 策略。 noeviction：无策略。  从键的维度来看，分成了两种，一种是设置了过期时间的 key，另一种是所有key。
从策略维度看，分成四种：LRU最近访问时间、LFU访问频率、RANDOM随机，TTL过期时间。
  调用链 缓存策略的入口在processCommand里，这里会调用freeMemoryIfNeededAndSafe，然后调用freeMemoryIfNeeded。
int processCommand(client *c) { /* Handle the maxmemory directive. * * Note that we do not want to reclaim memory if we are here re-entering * the event loop since there is a busy Lua script running in timeout * condition, to avoid mixing the propagation of scripts with the * propagation of DELs due to eviction....</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-06 06:36:51 +0800 HKT'>November 6, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：内存淘汰策略" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Redis源码：aof
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 的另一个持久化的功能叫AOF（Append Only File），原理是用户执行一条命令，就追加记录一条下来，可以联想 MySQL 的 binlog。
初始化 Redis 通过loadServerConfig加载配置appendonly [yes|no]，对应会修改server.aof_state = AOF_ON|AOF_OFF。当AOF被开启，Redis 初始化服务initServer时会打开一个AOF文件并记录下对应的 fd。
此时的几个相关字段：
struct redisServer { int aof_state; /* aof状态 */ int aof_fd; /* aof文件fd */ char *aof_filename; /* aof文件名 */ } 记录写入 Redis 在调用call函数里会去追加记录AOF，它在c-&gt;cmd-&gt;proc(c)后，会执行propagate，然后再执行feedAppendOnlyFile。
feedAppendOnlyFile主要逻辑：
 判断当前命令的 db 是否和AOF的 db 相同，如果不相同，AOF记录一条select db进行数据库切换。 所有过期expire命令都转换成PEXPIREAT命令。 所有set类的命令，都转换成set命令 如果当前AOF处于AOF_ON的状态，则写入缓冲区。 如果当前AOF有子进程，则调用aofRewriteBufferAppend。  此时所有操作都只是写入缓冲区，而数据并未落盘。
写入时机 AOF会以RESP协议（Redis 的通讯协议）来记录我们每一条命令，它会依赖三种策略：
  AOF_FSYNC_NO
不手动刷盘，而是由系统自己决定。
  AOF_FSYNC_ALWAYS
每条命令刷盘一次，这种方式丢数据的机率最小，最多会丢一条记录。
  AOF_FSYNC_EVERYSEC
每秒记录刷盘一次。
  Redis 会调用flushAppendOnlyFile进行AOF的数据落盘，最常见的调用时机就是每次事件循环的前置函数beforeSleep。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-01 23:54:03 +0800 HKT'>November 1, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：aof" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81aof/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://rudychow.github.io/">« Prev Page</a>
    <a class="next" href="https://rudychow.github.io/page/3/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
