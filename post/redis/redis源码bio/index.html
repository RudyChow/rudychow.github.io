<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis源码：bio | Rudy&#39;s blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。
初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。
实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：
// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created.">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Redis源码：bio" />
<meta property="og:description" content="Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。
初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。
实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：
// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-12T16:39:29&#43;08:00" />
<meta property="article:modified_time" content="2020-10-12T16:39:29&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis源码：bio"/>
<meta name="twitter:description" content="Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。
初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。
实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：
// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://rudychow.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Redis源码：bio",
      "item": "https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis源码：bio",
  "name": "Redis源码：bio",
  "description": "Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。\n初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。\n实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：\n// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created.",
  "keywords": [
    
  ],
  "articleBody": "Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。\n初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。\n实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：\n// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created. */ /* Job specific arguments pointers. If we need to pass more than three * arguments we can just pass a pointer to a structure or alike. */ void *arg1, *arg2, *arg3; }; 线程的初始化函数：\nvoid bioInit(void) { pthread_attr_t attr; pthread_t thread; size_t stacksize; int j; // 初始化线程相关变量  for (j = 0; j  BIO_NUM_OPS; j++) { pthread_mutex_init(\u0026bio_mutex[j],NULL); pthread_cond_init(\u0026bio_newjob_cond[j],NULL); pthread_cond_init(\u0026bio_step_cond[j],NULL); bio_jobs[j] = listCreate(); bio_pending[j] = 0; } /* Set the stack size as by default it may be small in some system */ pthread_attr_init(\u0026attr); pthread_attr_getstacksize(\u0026attr,\u0026stacksize); if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */ while (stacksize  REDIS_THREAD_STACK_SIZE) stacksize *= 2; pthread_attr_setstacksize(\u0026attr, stacksize); // 创建 3 个线程  for (j = 0; j  BIO_NUM_OPS; j++) { void *arg = (void*)(unsigned long) j; if (pthread_create(\u0026thread,\u0026attr,bioProcessBackgroundJobs,arg) != 0) { serverLog(LL_WARNING,\"Fatal: Can't initialize Background Jobs.\"); exit(1); } bio_threads[j] = thread; } } 简要说明，就是预先初始好几个相关数组，然后创建 3 个线程，让线程去执行bioProcessBackgroundJobs，这个函数就是我们后台线程的主要执行逻辑。\nbioProcessBackgroundJobs的具体逻辑如下：\nvoid *bioProcessBackgroundJobs(void *arg) { struct bio_job *job; unsigned long type = (unsigned long) arg; sigset_t sigset; // 线程数量判断  if (type = BIO_NUM_OPS) { serverLog(LL_WARNING, \"Warning: bio thread started with wrong type %lu\",type); return NULL; } // 设置线程可被终止，让bioKillThreads可以正常执行  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL); pthread_mutex_lock(\u0026bio_mutex[type]); // 屏蔽SIGALRM信号  sigemptyset(\u0026sigset); sigaddset(\u0026sigset, SIGALRM); if (pthread_sigmask(SIG_BLOCK, \u0026sigset, NULL)) serverLog(LL_WARNING, \"Warning: can't mask SIGALRM in bio.c thread: %s\", strerror(errno)); // 此处进入死循环  while(1) { listNode *ln; // 有新的job实例才进行逻辑  if (listLength(bio_jobs[type]) == 0) { pthread_cond_wait(\u0026bio_newjob_cond[type],\u0026bio_mutex[type]); continue; } /* Pop the job from the queue. */ ln = listFirst(bio_jobs[type]); job = ln-value; /* It is now possible to unlock the background system as we know have * a stand alone job structure to process.*/ pthread_mutex_unlock(\u0026bio_mutex[type]); // 第一个线程，执行close操作  if (type == BIO_CLOSE_FILE) { close((long)job-arg1); // 第二个线程，执行AOF刷盘操作  } else if (type == BIO_AOF_FSYNC) { redis_fsync((long)job-arg1); // 第三个线程，执行释放空间操作  } else if (type == BIO_LAZY_FREE) { /* What we free changes depending on what arguments are set: * arg1 - free the object at pointer. * arg2 \u0026 arg3 - free two dictionaries (a Redis DB). * only arg3 - free the skiplist. */ if (job-arg1) lazyfreeFreeObjectFromBioThread(job-arg1); else if (job-arg2 \u0026\u0026 job-arg3) lazyfreeFreeDatabaseFromBioThread(job-arg2,job-arg3); else if (job-arg3) lazyfreeFreeSlotsMapFromBioThread(job-arg3); } else { serverPanic(\"Wrong job type in bioProcessBackgroundJobs().\"); } zfree(job); /* Lock again before reiterating the loop, if there are no longer * jobs to process we'll block again in pthread_cond_wait(). */ pthread_mutex_lock(\u0026bio_mutex[type]); listDelNode(bio_jobs[type],ln); bio_pending[type]--; /* Unblock threads blocked on bioWaitStepOfType() if any. */ pthread_cond_broadcast(\u0026bio_step_cond[type]); } } 简单的结构图：\n结语 Redis 之所以实现 bio，原因很简单：把主线程的一些耗时的工作，移到后台线程中去做。比如 Redis4 之后新增的unlink操作，就是用来替代del的。因为在一些比较大的数据下，del会因为操作太久导致整个事件循环的阻塞。\n",
  "wordCount" : "482",
  "inLanguage": "en",
  "datePublished": "2020-10-12T16:39:29+08:00",
  "dateModified": "2020-10-12T16:39:29+08:00",
  "author":{
    "@type": "Person",
    "name": "Rudy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Rudy's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rudychow.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Redis源码：bio
    </h1>
    <div class="post-meta"><span title='2020-10-12 16:39:29 +0800 HKT'>October 12, 2020</span>&nbsp;·&nbsp;Rudy

</div>
  </header> 
  <div class="post-content"><p>Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。</p>
<h2 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h2>
<p>bio 的初始化在<code>src/server.c</code>中的<code>InitServerLast</code>函数，函数接着会调用<code>src/bio.c</code>的<code>bioInit</code>函数。</p>
<h2 id="实现逻辑">实现逻辑<a hidden class="anchor" aria-hidden="true" href="#实现逻辑">#</a></h2>
<p>与 bio 相关的几个宏定义、变量以及结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 后台线程的类型
</span><span style="color:#75715e"></span><span style="color:#75715e">#define BIO_CLOSE_FILE    0 </span><span style="color:#75715e">/* Deferred close(2) syscall. */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define BIO_AOF_FSYNC     1 </span><span style="color:#75715e">/* Deferred AOF fsync. */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define BIO_LAZY_FREE     2 </span><span style="color:#75715e">/* Deferred objects freeing. */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// 线程数量
</span><span style="color:#75715e"></span><span style="color:#75715e">#define BIO_NUM_OPS       3
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 线程数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> pthread_t bio_threads[BIO_NUM_OPS];
<span style="color:#75715e">// 线程锁数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> pthread_mutex_t bio_mutex[BIO_NUM_OPS];
<span style="color:#75715e">// 线程条件变量数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];
<span style="color:#66d9ef">static</span> pthread_cond_t bio_step_cond[BIO_NUM_OPS];
<span style="color:#75715e">// 任务数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> list <span style="color:#f92672">*</span>bio_jobs[BIO_NUM_OPS];
<span style="color:#75715e">// 待处理任务数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> bio_pending[BIO_NUM_OPS];

<span style="color:#75715e">// bio的每一个执行任务结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> bio_job {
    time_t time; <span style="color:#75715e">/* Time at which the job was created. */</span>
    <span style="color:#75715e">/* Job specific arguments pointers. If we need to pass more than three
</span><span style="color:#75715e">     * arguments we can just pass a pointer to a structure or alike. */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg1, <span style="color:#f92672">*</span>arg2, <span style="color:#f92672">*</span>arg3;
};
</code></pre></div><p>线程的初始化函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bioInit</span>(<span style="color:#66d9ef">void</span>) {
    pthread_attr_t attr;
    pthread_t <span style="color:#66d9ef">thread</span>;
    size_t stacksize;
    <span style="color:#66d9ef">int</span> j;

    <span style="color:#75715e">// 初始化线程相关变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> BIO_NUM_OPS; j<span style="color:#f92672">++</span>) {
        pthread_mutex_init(<span style="color:#f92672">&amp;</span>bio_mutex[j],NULL);
        pthread_cond_init(<span style="color:#f92672">&amp;</span>bio_newjob_cond[j],NULL);
        pthread_cond_init(<span style="color:#f92672">&amp;</span>bio_step_cond[j],NULL);
        bio_jobs[j] <span style="color:#f92672">=</span> listCreate();
        bio_pending[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#75715e">/* Set the stack size as by default it may be small in some system */</span>
    pthread_attr_init(<span style="color:#f92672">&amp;</span>attr);
    pthread_attr_getstacksize(<span style="color:#f92672">&amp;</span>attr,<span style="color:#f92672">&amp;</span>stacksize);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>stacksize) stacksize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* The world is full of Solaris Fixes */</span>
    <span style="color:#66d9ef">while</span> (stacksize <span style="color:#f92672">&lt;</span> REDIS_THREAD_STACK_SIZE) stacksize <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
    pthread_attr_setstacksize(<span style="color:#f92672">&amp;</span>attr, stacksize);

    <span style="color:#75715e">// 创建 3 个线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> BIO_NUM_OPS; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) j;
        <span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span>,<span style="color:#f92672">&amp;</span>attr,bioProcessBackgroundJobs,arg) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            serverLog(LL_WARNING,<span style="color:#e6db74">&#34;Fatal: Can&#39;t initialize Background Jobs.&#34;</span>);
            exit(<span style="color:#ae81ff">1</span>);
        }
        bio_threads[j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">thread</span>;
    }
}
</code></pre></div><p>简要说明，就是预先初始好几个相关数组，然后创建 3 个线程，让线程去执行<code>bioProcessBackgroundJobs</code>，这个函数就是我们后台线程的主要执行逻辑。</p>
<p><code>bioProcessBackgroundJobs</code>的具体逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bioProcessBackgroundJobs</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">struct</span> bio_job <span style="color:#f92672">*</span>job;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> type <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) arg;
    sigset_t sigset;

    <span style="color:#75715e">// 线程数量判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">&gt;=</span> BIO_NUM_OPS) {
        serverLog(LL_WARNING,
            <span style="color:#e6db74">&#34;Warning: bio thread started with wrong type %lu&#34;</span>,type);
        <span style="color:#66d9ef">return</span> NULL;
    }

    <span style="color:#75715e">// 设置线程可被终止，让bioKillThreads可以正常执行
</span><span style="color:#75715e"></span>    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);

    pthread_mutex_lock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);
    <span style="color:#75715e">// 屏蔽SIGALRM信号
</span><span style="color:#75715e"></span>    sigemptyset(<span style="color:#f92672">&amp;</span>sigset);
    sigaddset(<span style="color:#f92672">&amp;</span>sigset, SIGALRM);
    <span style="color:#66d9ef">if</span> (pthread_sigmask(SIG_BLOCK, <span style="color:#f92672">&amp;</span>sigset, NULL))
        serverLog(LL_WARNING,
            <span style="color:#e6db74">&#34;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&#34;</span>, strerror(errno));

    <span style="color:#75715e">// 此处进入死循环
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
        listNode <span style="color:#f92672">*</span>ln;

        <span style="color:#75715e">// 有新的job实例才进行逻辑
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (listLength(bio_jobs[type]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            pthread_cond_wait(<span style="color:#f92672">&amp;</span>bio_newjob_cond[type],<span style="color:#f92672">&amp;</span>bio_mutex[type]);
            <span style="color:#66d9ef">continue</span>;
        }
        <span style="color:#75715e">/* Pop the job from the queue. */</span>
        ln <span style="color:#f92672">=</span> listFirst(bio_jobs[type]);
        job <span style="color:#f92672">=</span> ln<span style="color:#f92672">-&gt;</span>value;
        <span style="color:#75715e">/* It is now possible to unlock the background system as we know have
</span><span style="color:#75715e">         * a stand alone job structure to process.*/</span>
        pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);

        <span style="color:#75715e">// 第一个线程，执行close操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_CLOSE_FILE) {
            close((<span style="color:#66d9ef">long</span>)job<span style="color:#f92672">-&gt;</span>arg1);
        <span style="color:#75715e">// 第二个线程，执行AOF刷盘操作
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_AOF_FSYNC) {
            redis_fsync((<span style="color:#66d9ef">long</span>)job<span style="color:#f92672">-&gt;</span>arg1);
        <span style="color:#75715e">// 第三个线程，执行释放空间操作
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_LAZY_FREE) {
            <span style="color:#75715e">/* What we free changes depending on what arguments are set:
</span><span style="color:#75715e">             * arg1 -&gt; free the object at pointer.
</span><span style="color:#75715e">             * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).
</span><span style="color:#75715e">             * only arg3 -&gt; free the skiplist. */</span>
            <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg1)
                lazyfreeFreeObjectFromBioThread(job<span style="color:#f92672">-&gt;</span>arg1);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg2 <span style="color:#f92672">&amp;&amp;</span> job<span style="color:#f92672">-&gt;</span>arg3)
                lazyfreeFreeDatabaseFromBioThread(job<span style="color:#f92672">-&gt;</span>arg2,job<span style="color:#f92672">-&gt;</span>arg3);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg3)
                lazyfreeFreeSlotsMapFromBioThread(job<span style="color:#f92672">-&gt;</span>arg3);
        } <span style="color:#66d9ef">else</span> {
            serverPanic(<span style="color:#e6db74">&#34;Wrong job type in bioProcessBackgroundJobs().&#34;</span>);
        }
        zfree(job);

        <span style="color:#75715e">/* Lock again before reiterating the loop, if there are no longer
</span><span style="color:#75715e">         * jobs to process we&#39;ll block again in pthread_cond_wait(). */</span>
        pthread_mutex_lock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);
        listDelNode(bio_jobs[type],ln);
        bio_pending[type]<span style="color:#f92672">--</span>;

        <span style="color:#75715e">/* Unblock threads blocked on bioWaitStepOfType() if any. */</span>
        pthread_cond_broadcast(<span style="color:#f92672">&amp;</span>bio_step_cond[type]);
    }
}
</code></pre></div><p>简单的结构图：</p>
<p><img loading="lazy" src="/pics/redis/bio/bio.jpg" alt="bio"  />
</p>
<h2 id="结语">结语<a hidden class="anchor" aria-hidden="true" href="#结语">#</a></h2>
<p>Redis 之所以实现 bio，原因很简单：把主线程的一些耗时的工作，移到后台线程中去做。比如 Redis4 之后新增的<code>unlink</code>操作，就是用来替代<code>del</code>的。因为在一些比较大的数据下，<code>del</code>会因为操作太久导致整个事件循环的阻塞。</p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0main/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Redis源码：入口函数main</span>
  </a>
  <a class="next" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81object/">
    <span class="title">Next Page »</span>
    <br>
    <span>Redis源码：object</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
