<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rudy&#39;s blog</title>
    <link>https://rudychow.github.io/post/</link>
    <description>Recent content in Posts on Rudy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 03 Jan 2021 23:42:34 +0800</lastBuildDate><atom:link href="https://rudychow.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Join算法</title>
      <link>https://rudychow.github.io/post/MySQL/join%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 03 Jan 2021 23:42:34 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/join%E7%AE%97%E6%B3%95/</guid>
      <description>MySQL 目前主要的 join 算法有两类：Hash Join 和 Nested-Loop Join。 Hash Join Hash Join 是 MySQL 在 8.0.18 后支持的连表算法，这个时候的 Hash Join 有两个阶段： build 构建阶段下，MySQL 会将小的表作为构建，构建的</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://rudychow.github.io/post/MySQL/%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 28 Dec 2020 22:58:32 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务是数据库区别于文件系统的重要特性之一。数据库系统引入事务的主要目的：事务会把数据库从一种一致状态转移为另一种一致状态。在数据库提交工作时，可以确保要么所有修</description>
    </item>
    
    <item>
      <title>undo日志</title>
      <link>https://rudychow.github.io/post/MySQL/undo%E6%97%A5%E5%BF%97/</link>
      <pubDate>Sun, 13 Dec 2020 21:33:54 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/undo%E6%97%A5%E5%BF%97/</guid>
      <description>undo log 主要有两个作用：事务回滚和 MVCC。 到底是什么是 undo log ？前面说到 InnoDB 表空间存放着许多不同类型的页，undo log 就是其中的一种类型。它和 redo log 不同，是一种逻辑日志，记</description>
    </item>
    
    <item>
      <title>B&#43;树二叉查询</title>
      <link>https://rudychow.github.io/post/MySQL/B&#43;%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sun, 13 Dec 2020 17:53:23 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/B&#43;%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E8%AF%A2/</guid>
      <description>B+树是通过二叉查找树，再由平衡二叉树，B数演化而来。 我们知道从一组有序数字数组中查找目标记录，使用二分查找法（Binary Search）是一种有效的方式，复杂</description>
    </item>
    
    <item>
      <title>Vscode下使用GDB调试Redis</title>
      <link>https://rudychow.github.io/post/Redis/Vscode%E4%B8%8B%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95Redis/</link>
      <pubDate>Sun, 13 Dec 2020 13:45:54 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Vscode%E4%B8%8B%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95Redis/</guid>
      <description>配置.vscode/launch.json： { &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;configurations&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;redis启动&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;cppdbg&amp;#34;, &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;, &amp;#34;program&amp;#34;: &amp;#34;${workspaceFolder}/src/redis-server&amp;#34;, &amp;#34;args&amp;#34;: [&amp;#34;${workspaceFolder}/redis.conf&amp;#34;], &amp;#34;stopAtEntry&amp;#34;: false, &amp;#34;cwd&amp;#34;: &amp;#34;${workspaceFolder}&amp;#34;, &amp;#34;environment&amp;#34;: [], &amp;#34;externalConsole&amp;#34;: false, &amp;#34;MIMode&amp;#34;: &amp;#34;gdb&amp;#34;, &amp;#34;preLaunchTask&amp;#34;: &amp;#34;make redis&amp;#34;, &amp;#34;setupCommands&amp;#34;: [ { &amp;#34;description&amp;#34;: &amp;#34;为 gdb 启</description>
    </item>
    
    <item>
      <title>InnoDB存储结构</title>
      <link>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 08 Dec 2020 23:09:35 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>从 InnoDB 存储引擎的逻辑存储结构看，所有数据都被逻辑地存在一个空间中，称为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（pa</description>
    </item>
    
    <item>
      <title>redo日志</title>
      <link>https://rudychow.github.io/post/MySQL/redo%E6%97%A5%E5%BF%97/</link>
      <pubDate>Sun, 06 Dec 2020 11:57:57 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/redo%E6%97%A5%E5%BF%97/</guid>
      <description>结合最近的学习总结一下 redo log 相关的知识，以及回答之前的困惑。 redo log 与 bin log 这两个日志是我之前经常迷惑的地方，因为两者在不同层面上都能实现恢复数据的效果。 要了解两者的区</description>
    </item>
    
    <item>
      <title>《InnoDB存储引擎》笔记：文件</title>
      <link>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 05 Dec 2020 19:04:43 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6/</guid>
      <description>这一章节重点在 bin log 以及 InnoDB 存储引擎文件。 参数文件 MySQL 实例启动时，会先读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，用户可以通过怕命令m</description>
    </item>
    
    <item>
      <title>《InnoDB存储引擎》笔记：InnoDB存储引擎</title>
      <link>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Fri, 04 Dec 2020 22:23:00 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>这一章节随便拿出一小节都可以单独写一篇文章，这里仅做笔记和总结。 体系架构 后台线程 InnoDB 存储引擎是多线程的模型，因此后台有多个不同的后台线程，负责处理不同的任务。 Master Thread</description>
    </item>
    
    <item>
      <title>《InnoDB存储引擎》笔记：MySQL体系结构和存储引擎</title>
      <link>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Fri, 04 Dec 2020 18:02:36 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>这一节主要是一些基础概念和介绍，所以此处只进行了基本的笔记总结。 数据库与实例 数据库：物理操作系统文件或其他形式文件类型的集合。 实例：MySQL 数据库由后台线程以</description>
    </item>
    
    <item>
      <title>Redis源码阅读阶段总结</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 16 Nov 2020 06:21:00 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</guid>
      <description>把 Redis 分成几个部分来阅读，目前的阅读情况： 多机： 集群 复制 哨兵 单机： ae db 持久化： AOF RDB 数据结构： SDS ZIPLIST INISET ADLIST SKIPLIST DICT QUICKLIST GEO OBJECT BITMAP HYPERLOGLOG 其它功能： BLOCK PUBSUB BIO EVICT SLOWLOG 事务 LUA Redis6： 多线程 ACL</description>
    </item>
    
    <item>
      <title>Redis源码：多线程</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 15 Nov 2020 16:31:01 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>Redis6 有了不少更新：ACL 权限、RESP3 协议、SSL等等，其中包括了多线程。 以往的 Redis 在处理网络 IO 时是单线程，在新版本中引入了多线程。默认是关闭的，需要修改配置进行</description>
    </item>
    
    <item>
      <title>Redis源码：内存淘汰策略</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</link>
      <pubDate>Fri, 06 Nov 2020 06:36:51 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</guid>
      <description>当 Redis 的内存达到一定值时，会触发自身的内存淘汰策略，目的是为了避免内存的增长。Redis 内存相关的淘汰策略代码主要在src/evict.c里。 相关配置 配置文件中的</description>
    </item>
    
    <item>
      <title>Redis源码：aof</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81aof/</link>
      <pubDate>Sun, 01 Nov 2020 23:54:03 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81aof/</guid>
      <description>Redis 的另一个持久化的功能叫AOF（Append Only File），原理是用户执行一条命令，就追加记录一条下来，可以联想 MySQL 的 binlog。 初始化 Redis 通过loadServer</description>
    </item>
    
    <item>
      <title>Redis源码：rdb</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81rdb/</link>
      <pubDate>Sat, 31 Oct 2020 20:40:57 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81rdb/</guid>
      <description>Redis 有两种数据持久化策略，其中一种是RDB（Redis database），属于快照持久化的方式。它分为主动备份和定时备份两种方式去运行。 主动备份 当执行save或者</description>
    </item>
    
    <item>
      <title>Redis源码：事务</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Fri, 30 Oct 2020 18:39:35 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%BA%8B%E5%8A%A1/</guid>
      <description>Redis 与事务相关的命令有：multi、discard、exec和watch。 multi、discard和exec这是一组命令，与MySQL的begin、rollba</description>
    </item>
    
    <item>
      <title>Redis源码：pub和sub</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81pub%E5%92%8Csub/</link>
      <pubDate>Wed, 28 Oct 2020 23:52:02 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81pub%E5%92%8Csub/</guid>
      <description>Redis 中使用订阅与发布同样可以达到 block 的效果。 数据结构 客户端： typedef struct client { dict *pubsub_channels; /* 普通订阅，key是channel，value为null */ list *pubsub_patterns; /* 匹配模式的订阅*/ } client; 服务端</description>
    </item>
    
    <item>
      <title>Redis源码：从bpop看block</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%BB%8Ebpop%E7%9C%8Bblock/</link>
      <pubDate>Mon, 26 Oct 2020 23:48:25 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%BB%8Ebpop%E7%9C%8Bblock/</guid>
      <description>Redis 中可以通过brpop、blpop和brpoplpush来实现对列表的阻塞 pop 操作。 Redis 在处理主逻辑是单线程的，如果使用上述的命令进行阻塞操作的话，后面的请求也会一</description>
    </item>
    
    <item>
      <title>Redis源码：一个命令的执行流程</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Thu, 15 Oct 2020 11:23:53 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
      <description>一个命令的执行过程，我们大概可以分成三步骤：建立连接，发送命令，得到结果。下面会针对这三个命令，结合源码进行分析： 建立连接 建立连接要从acceptTcpHand</description>
    </item>
    
    <item>
      <title>Redis源码：redisDB</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81redisDB/</link>
      <pubDate>Wed, 14 Oct 2020 22:22:47 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81redisDB/</guid>
      <description>redisDB 即是 database，是 Redis 的数据库。它是变量server里的一个成员变量数组，数组大小默认是 16。 客户端默认使用第一个数据库，其间可以使用select进行 db 的</description>
    </item>
    
    <item>
      <title>Redis源码：入口函数main</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0main/</link>
      <pubDate>Wed, 14 Oct 2020 15:03:38 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0main/</guid>
      <description>main 函数是程序执行的起点，也是大家就阅读源码的入口。要了解 Redis 的初始化和运行过程，还是要通过 main 函数入手。 已一个单机的 Redis 为例，main 函数主要可以分成以下几个步骤： 初</description>
    </item>
    
    <item>
      <title>Redis源码：bio</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81bio/</link>
      <pubDate>Mon, 12 Oct 2020 16:39:29 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81bio/</guid>
      <description>Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。 初始化 bio 的初始化在sr</description>
    </item>
    
    <item>
      <title>Redis源码：object</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81object/</link>
      <pubDate>Sun, 11 Oct 2020 12:25:01 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81object/</guid>
      <description>我们经常使用 Redis 的基础命令有string、set、list、hashtable和zset。在 Redis 的底层中，我们不是直接使用它们对应的数据结构，而是通过 object 对这些基础命</description>
    </item>
    
    <item>
      <title>Redis源码：skiplist</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81skiplist/</link>
      <pubDate>Thu, 08 Oct 2020 12:13:32 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81skiplist/</guid>
      <description>skiplist 是 Redis 对于跳跃表的一个实现，它也是 zset 的主要实现。网上关于 skiplist 数据结构的介绍有很多，这里主要记录 Redis 中的实现方式。 数据结构 // 跳表节点 typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward;</description>
    </item>
    
    <item>
      <title>Redis源码：intset</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81intset/</link>
      <pubDate>Thu, 08 Oct 2020 10:46:35 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81intset/</guid>
      <description>intset 就是整数集合。这个集合只包含了整数，并且不回有重复数据。Redis 常用的 set 命令，当符合 intset 的情况时，底层就会使用 intset 去实现，其余情况则使用 dict。 数据结构 #define INTSET_ENC_INT16 (sizeof(int16_t))</description>
    </item>
    
    <item>
      <title>Redis源码：dict</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81dict/</link>
      <pubDate>Wed, 07 Oct 2020 22:26:33 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81dict/</guid>
      <description>dict 是 Redis 对于 hashtable 的表现，我们常用的 hash 命令底层就是通过 dict 实现的（严谨一点的话，一开始会使用 ziplist 作为实现，到一定阈值后才使用 dict）。 数据结构 // 字典 typedef struct dict { dictType *type; void *privdata; dictht ht[2];</description>
    </item>
    
    <item>
      <title>Redis源码：quicklist</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81quicklist/</link>
      <pubDate>Wed, 07 Oct 2020 15:34:26 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81quicklist/</guid>
      <description>quicklist 全称是a generic doubly linked quicklist，从全称可以看得出这是一个节点存放 ziplist 的双向链表。我们常用的 list 功能，底层就是使用 quicklist 实现的。 数据结构 // 双向链表结构体 typedef struct quicklist { quicklistNode *head; quicklistNode</description>
    </item>
    
    <item>
      <title>Redis源码：ziplist</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81ziplist/</link>
      <pubDate>Tue, 06 Oct 2020 18:40:41 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81ziplist/</guid>
      <description>ziplist，又称作压缩列表，它是 Redis 内部定义的连续的内存组成的数据结构，目的是减少内存碎片，节省内存空间。 数据结构 ziplist主要由三部分组成：header</description>
    </item>
    
    <item>
      <title>Redis源码：adlist</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81adlist/</link>
      <pubDate>Mon, 05 Oct 2020 15:45:16 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81adlist/</guid>
      <description>adlist 全称是a generic doubly linked list，是 Redis 内部实现的一个双向链表。旧版本中，list 是使用 adlist 实现的，后面的版本改成用 quicklist 实现。 数据结构 // 链表节点 typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; //</description>
    </item>
    
    <item>
      <title>Redis源码：sds</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81sds/</link>
      <pubDate>Fri, 25 Sep 2020 23:09:58 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81sds/</guid>
      <description>sds 全称是simple dynamic string，是 Redis 用来实现字符串的一个数据结构。 数据结构 在 C 中，简单的动态字符串结构通常会记录长度和内容： struct string { char *buf;// 字符指针 uint32_t len; // 字符串长</description>
    </item>
    
    <item>
      <title>Redis源码：AE时间事件</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81AE%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Wed, 23 Sep 2020 23:40:53 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81AE%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6/</guid>
      <description>Redis 的时间事件相比起文件事件简单不少（以 Redis5.0.9 为例）。 aeEventLoop aeEventLoop是Redis全局的结构体对象，所有跟事件有关的数据和状态都存储在这上面： // 只展示时间事件</description>
    </item>
    
    <item>
      <title>Redis源码：AE文件事件</title>
      <link>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81AE%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sat, 19 Sep 2020 11:46:17 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Redis/Redis%E6%BA%90%E7%A0%81AE%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6/</guid>
      <description>Redis 的事件模块分为文件事件和时间事件。文件事件主要是处理网络 IO 事件，而时间事件主要处理 Redis 自身的一些定时任务。 这里会先对 Redis 的文件事件的源码进行简单地阅读并且分析（以</description>
    </item>
    
    <item>
      <title>Linux源码：select浅析</title>
      <link>https://rudychow.github.io/post/Linux%E6%BA%90%E7%A0%81select/</link>
      <pubDate>Wed, 09 Sep 2020 22:28:29 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Linux%E6%BA%90%E7%A0%81select/</guid>
      <description>因为 Linux 源码中 select 的代码量不多，所以尝试阅读一下 select 的源码。阅读过程主要以读懂基础流程为主，对于尚未理解或者过于难懂的地方暂时略过。（下面以 Linux5.7 为准） 通过man 2 sel</description>
    </item>
    
    <item>
      <title>PHP扩展：实现snowflake分布式id（2）</title>
      <link>https://rudychow.github.io/post/PHP/PHP%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid2/</link>
      <pubDate>Fri, 28 Aug 2020 00:29:51 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/PHP/PHP%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid2/</guid>
      <description>前期准备 首先需要下载PHP源码：下载地址。（这里我使用的PHP版本是7.4.9，系统环境是x86_64 Linux 5.7.17-2-MANJARO） 解压后，进入到ext目</description>
    </item>
    
    <item>
      <title>PHP扩展：实现snowflake分布式id（1）</title>
      <link>https://rudychow.github.io/post/PHP/PHP%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid1/</link>
      <pubDate>Mon, 24 Aug 2020 23:48:32 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/PHP/PHP%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid1/</guid>
      <description>Snowflake，又称为雪花算法，是Twitter开源的高性能分布式ID的生成算法。关于snowflake的介绍，网上有很多，这里不再赘述。 结构 snowfla</description>
    </item>
    
    <item>
      <title>MySQL索引相关概念（1）</title>
      <link>https://rudychow.github.io/post/MySQL/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B51/</link>
      <pubDate>Mon, 17 Aug 2020 23:53:56 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/MySQL/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B51/</guid>
      <description>前缀索引（Index Prefixes） 前缀索引，即是你可以通过字段的前N个字符去创建一个索引。当你想为TEXT或者BLOB字段创建索引时，必须指定长度。 ## 创建测</description>
    </item>
    
    <item>
      <title>线上问题：锁超时</title>
      <link>https://rudychow.github.io/post/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E9%94%81%E8%B6%85%E6%97%B6/</link>
      <pubDate>Fri, 31 Jul 2020 23:28:01 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E9%94%81%E8%B6%85%E6%97%B6/</guid>
      <description>问题记录 门店反馈POS机在用户成功付款时等待很久，并且弹出错误提示。于是查看日志，发现相关接口出现数据库锁超时的报错：Lock wait timeout exceeded; try restarting transaction。</description>
    </item>
    
    <item>
      <title>Nginx客户端断开连接的日志记录</title>
      <link>https://rudychow.github.io/post/Nginx%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 20 Jul 2020 23:27:34 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/Nginx%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</guid>
      <description>最近跟同事讨论问题时提到Nginx客户端断开连接时的日志问题。 同事说客户端异常断开连接时，记录的会是200日志。之前一直认为客户端断开连接时，Nginx会以49</description>
    </item>
    
    <item>
      <title>线上问题：到底是几次请求？</title>
      <link>https://rudychow.github.io/post/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E5%88%B0%E5%BA%95%E6%98%AF%E5%87%A0%E6%AC%A1%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Fri, 03 Jul 2020 18:52:50 +0800</pubDate>
      
      <guid>https://rudychow.github.io/post/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E5%88%B0%E5%BA%95%E6%98%AF%E5%87%A0%E6%AC%A1%E8%AF%B7%E6%B1%82/</guid>
      <description>问题记录 运营反馈的问题：顾客成功付款，但是POS机显示在Loading，最后弹窗提示“请校准系统时间”，但是在管理后台能查看到顾客成功付款的订单数据。 POS机发</description>
    </item>
    
  </channel>
</rss>
