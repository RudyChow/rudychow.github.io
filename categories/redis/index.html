<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis | Rudy&#39;s blog</title>
<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/categories/redis/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />
<link rel="alternate" type="application/rss+xml" href="https://rudychow.github.io/categories/redis/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Redis" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://rudychow.github.io/categories/redis/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>Redis</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Vscode下使用GDB调试Redis
    </h2>
  </header>
  <section class="entry-content">
    <p> 配置.vscode/launch.json：  { &#34;version&#34;: &#34;0.2.0&#34;, &#34;configurations&#34;: [ { &#34;name&#34;: &#34;redis启动&#34;, &#34;type&#34;: &#34;cppdbg&#34;, &#34;request&#34;: &#34;launch&#34;, &#34;program&#34;: &#34;${workspaceFolder}/src/redis-server&#34;, &#34;args&#34;: [&#34;${workspaceFolder}/redis.conf&#34;], &#34;stopAtEntry&#34;: false, &#34;cwd&#34;: &#34;${workspaceFolder}&#34;, &#34;environment&#34;: [], &#34;externalConsole&#34;: false, &#34;MIMode&#34;: &#34;gdb&#34;, &#34;preLaunchTask&#34;: &#34;make redis&#34;, &#34;setupCommands&#34;: [ { &#34;description&#34;: &#34;为 gdb 启用整齐打印&#34;, &#34;text&#34;: &#34;-enable-pretty-printing&#34;, &#34;ignoreFailures&#34;: true } ] } ] } 配置.vscode/tasks.json：  { &#34;version&#34;: &#34;2.0.0&#34;, &#34;tasks&#34;: [ { &#34;label&#34;: &#34;make redis&#34;, &#34;type&#34;: &#34;shell&#34;, &#34;command&#34;: &#34;make&#34;, &#34;args&#34;: [ &#34;CFLAGS=\&#34;-g -O0\&#34;&#34; ], &#34;options&#34;: { &#34;cwd&#34;: &#34;${workspaceFolder}/src&#34; } } ] } Start Debugging  </p>
  </section>
  <footer class="entry-footer"><span title='2020-12-13 13:45:54 +0800 HKT'>December 13, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Vscode下使用GDB调试Redis" href="https://rudychow.github.io/post/redis/vscode%E4%B8%8B%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95redis/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码阅读阶段总结
    </h2>
  </header>
  <section class="entry-content">
    <p>把 Redis 分成几个部分来阅读，目前的阅读情况：
多机：
 集群 复制 哨兵  单机：
 ae db  持久化：
 AOF RDB  数据结构：
 SDS ZIPLIST INISET ADLIST SKIPLIST DICT QUICKLIST GEO OBJECT BITMAP HYPERLOGLOG  其它功能：
 BLOCK PUBSUB BIO EVICT SLOWLOG 事务 LUA  Redis6：
 多线程 ACL TLS  作为非 C 程序员，第一次看关于 C 的项目源码，没有想象中吃力。
Redis 的项目结构非常清晰简单，比如 ae 功能，对应就是一个ae.h头文件和ae.c源文件，加上ae_*.c其它相关的文件。只要看一下这些文件的 API，并且搜索一下这些 API 在整个运行流程中的调用位置，就大概可以了解这个功能。
项目的注释也非常齐全，在一些比较复杂或者逻辑比较多的函数，都会有大段的注释，阅读起来非常方便。
虽然是用 C 写的项目，但是大部分都觉得非常得面向对象。比如服务器，即是一个全局的redisServer结构体变量，每个客户端就是一个client结构体变量，并且用了很多函数指针，使用起来和对象没什么区别。
后面有时间会把其余的功能也阅读一遍。</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-16 06:21:00 +0800 HKT'>November 16, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码阅读阶段总结" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：多线程
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis6 有了不少更新：ACL 权限、RESP3 协议、SSL等等，其中包括了多线程。
以往的 Redis 在处理网络 IO 时是单线程，在新版本中引入了多线程。默认是关闭的，需要修改配置进行开启。
相关配置与变量 有两个配置参数会影响到多线程：
// 线程数量，默认是1，即只有主线程，最大是128 io-threads [1~128] // 是否通过辅助线程来读取并解析客户端，默认是0 io-threads-do-reads [0|1] 还有几个相关的结构体字段以及全局变量：
struct redisServer { int io_threads_num; /* Number of IO threads to use. */ int io_threads_do_reads; /* Read and parse from IO threads? */ int io_threads_active; /* Is IO threads currently active? */ }; // 多线程目前需要进行的操作开关，有IO_THREADS_OP_WRITE和IO_THREADS_OP_READ int io_threads_op; // 下标是线程id，值是客户端链表 list *io_threads_list[IO_THREADS_MAX_NUM]; // 下标是线程id，值是需要处理的客户端数量，该变量具有原子性 _Atomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM]; 开启多线程 多线程的开启在src/server.c中的InitServerLast中。以往该函数负责开启bio，新版本中还会调用initThreadedIO来开启多线程。
initThreadedIO的逻辑很简单，这里会循环server.io_threads_num去初始化io_threads_list变量，并且创建server.io_threads_num-1个数量的线程。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-15 16:31:01 +0800 HKT'>November 15, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：多线程" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：内存淘汰策略
    </h2>
  </header>
  <section class="entry-content">
    <p>当 Redis 的内存达到一定值时，会触发自身的内存淘汰策略，目的是为了避免内存的增长。Redis 内存相关的淘汰策略代码主要在src/evict.c里。
相关配置 配置文件中的maxmemory和maxmemory-policy就可以对 Redis 进行淘汰策略的配置。
  maxmemory
Redis 可用的最大内存，也就是触发策略的阈值。32 位系统下默认是 3G 内存（受限于 4G 内存空间），64 位系统下不受限制。
  maxmemory-policy
相关的策略，一共有：
 volatile-lru：过期键 LRU 策略。 volatile-lfu：过期键 LFU 策略。 volatile-random：过期键 RANDOM 策略。 volatile-ttl：过期键 TTL 策略。 allkeys-lru：所有键 LRU 策略。 allkeys-lfu：所有键 LFU 策略。 allkeys-random：所有键 RANDOM 策略。 noeviction：无策略。  从键的维度来看，分成了两种，一种是设置了过期时间的 key，另一种是所有key。
从策略维度看，分成四种：LRU最近访问时间、LFU访问频率、RANDOM随机，TTL过期时间。
  调用链 缓存策略的入口在processCommand里，这里会调用freeMemoryIfNeededAndSafe，然后调用freeMemoryIfNeeded。
int processCommand(client *c) { /* Handle the maxmemory directive. * * Note that we do not want to reclaim memory if we are here re-entering * the event loop since there is a busy Lua script running in timeout * condition, to avoid mixing the propagation of scripts with the * propagation of DELs due to eviction....</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-06 06:36:51 +0800 HKT'>November 6, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：内存淘汰策略" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：aof
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 的另一个持久化的功能叫AOF（Append Only File），原理是用户执行一条命令，就追加记录一条下来，可以联想 MySQL 的 binlog。
初始化 Redis 通过loadServerConfig加载配置appendonly [yes|no]，对应会修改server.aof_state = AOF_ON|AOF_OFF。当AOF被开启，Redis 初始化服务initServer时会打开一个AOF文件并记录下对应的 fd。
此时的几个相关字段：
struct redisServer { int aof_state; /* aof状态 */ int aof_fd; /* aof文件fd */ char *aof_filename; /* aof文件名 */ } 记录写入 Redis 在调用call函数里会去追加记录AOF，它在c-&gt;cmd-&gt;proc(c)后，会执行propagate，然后再执行feedAppendOnlyFile。
feedAppendOnlyFile主要逻辑：
 判断当前命令的 db 是否和AOF的 db 相同，如果不相同，AOF记录一条select db进行数据库切换。 所有过期expire命令都转换成PEXPIREAT命令。 所有set类的命令，都转换成set命令 如果当前AOF处于AOF_ON的状态，则写入缓冲区。 如果当前AOF有子进程，则调用aofRewriteBufferAppend。  此时所有操作都只是写入缓冲区，而数据并未落盘。
写入时机 AOF会以RESP协议（Redis 的通讯协议）来记录我们每一条命令，它会依赖三种策略：
  AOF_FSYNC_NO
不手动刷盘，而是由系统自己决定。
  AOF_FSYNC_ALWAYS
每条命令刷盘一次，这种方式丢数据的机率最小，最多会丢一条记录。
  AOF_FSYNC_EVERYSEC
每秒记录刷盘一次。
  Redis 会调用flushAppendOnlyFile进行AOF的数据落盘，最常见的调用时机就是每次事件循环的前置函数beforeSleep。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-01 23:54:03 +0800 HKT'>November 1, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：aof" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81aof/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：rdb
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 有两种数据持久化策略，其中一种是RDB（Redis database），属于快照持久化的方式。它分为主动备份和定时备份两种方式去运行。
主动备份 当执行save或者bgsave时，Redis 就会进行一次RDB的持久化。如果数据量比较大的情况下，执行save是一个比较耗时的动作，所以会阻塞客户端。bgsave可以又称作background save，用来解决save阻塞的情况，此时会fork出一个子进程来执行save命令。
save 先看save对应的saveCommand源码：
void saveCommand(client *c) { if (server.rdb_child_pid != -1) { addReplyError(c,&#34;Background save already in progress&#34;); return; } rdbSaveInfo rsi, *rsiptr; rsiptr = rdbPopulateSaveInfo(&amp;rsi); if (rdbSave(server.rdb_filename,rsiptr) == C_OK) { addReply(c,shared.ok); } else { addReply(c,shared.err); } } rdbPopulateSaveInfo主要是 Redis 复制的一些预处理，由于尚未看复制相关的代码，所以这次暂时不展开。
rdbSave则是 Redis 实现RDB持久化的主要函数，这里 Redis 会调用自己封装的 io 操作库 rio 来写入数据。
bgsave bgsave对应的bgsaveCommand源码：
void bgsaveCommand(client *c) { int schedule = 0; /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite * is in progress....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-31 20:40:57 +0800 HKT'>October 31, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：rdb" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81rdb/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：事务
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 与事务相关的命令有：multi、discard、exec和watch。
multi、discard和exec这是一组命令，与MySQL的begin、rollback和commit有相似之处。watch则是监听某个键，如果键值发生了改编，在事务中则会更新客户端的状态。
数据结构 // 事务状态 typedef struct multiState { multiCmd *commands; /* 命令数组，元素是没一个事务中需要执行的命令，以先进先出的顺序保存 */ int count; /* 一共有多少个待处理的命令 */ int cmd_flags; /* The accumulated command flags OR-ed together. So if at least a command has a given flag, it will be set in this field. */ int minreplicas; /* MINREPLICAS for synchronous replication */ time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */ } multiState; // watch的信息 typedef struct watchedKey { robj *key; redisDb *db; } watchedKey; // 客户端相关的事务字段 typedef struct client { multiState mstate; /* 事务状态 */ list *watched_keys; /* watch的key，里面每个元素都是watchedKey结构体变量 */ } client; // db typedef struct redisDb { dict *watched_keys; /* watch的key，键是key，值是客户端链表 */ } redisDb; 状态 与事务相关的几个客户端状态有：...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-30 18:39:35 +0800 HKT'>October 30, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：事务" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%BA%8B%E5%8A%A1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：pub和sub
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 中使用订阅与发布同样可以达到 block 的效果。
数据结构 客户端：
typedef struct client { dict *pubsub_channels; /* 普通订阅，key是channel，value为null */ list *pubsub_patterns; /* 匹配模式的订阅*/ } client; 服务端：
struct redisServer { dict *pubsub_channels; /* 普通订阅，key是channel，value为客户端链表 */ list *pubsub_patterns; /* 匹配模式的订阅 */ }; 订阅 通过subscribeCommand中可以定位到订阅的源码，这里会对订阅的每个channel都调用pubsubSubscribeChannel，并且把客户端状态叠加订阅发布状态。
server.pubsub_channels是字典，键是频道，值是客户端链表。pubsubSubscribeChannel最主要工作就是往server.pubsub_channels的频道客户端链表里添加当前客户端。
发布 publishCommand是发布对应的函数，里面会调用pubsubPublishMessage进行消息推送。
函数里最主要做的就是，在server.pubsub_channels中寻找对应的频道，并且循环客户端链表，给每个客户端发送消息。然后会在server.pubsub_patterns中寻找匹配规则的客户端发送消息。
与block的不同 发布订阅的功能虽然可以实现block的功能，但是两者之间还是有区别：
 发布是群发消息，而 block 是先进先出，即 pop 操作。 发布订阅不区分 db，channel 是作用于整个 server。而 block 是作用于 db。 发布订阅没有超时时间限制，block 有超时限制。 发布订阅支持匹配模式  </p>
  </section>
  <footer class="entry-footer"><span title='2020-10-28 23:52:02 +0800 HKT'>October 28, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：pub和sub" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81pub%E5%92%8Csub/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：从bpop看block
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 中可以通过brpop、blpop和brpoplpush来实现对列表的阻塞 pop 操作。
Redis 在处理主逻辑是单线程的，如果使用上述的命令进行阻塞操作的话，后面的请求也会一并阻塞。但是实际场景下，这几个命令并不会造成其它客户端阻塞，所以这里会从源码角度看看 Redis 怎么实现这些功能的。
阻塞状态 首先从redisCommandTable中找到brpop的命令入口以及整个调用链：brpopCommand-&gt;blockingPopGenericCommand-&gt;blockForKeys。
brpopCommand里只会调用blockingPopGenericCommand，blockingPopGenericCommand则会判断目标列表是否有元素，如果有，则直接返回，如果列表为空或者不存在该键，则调用blockForKeys。
在看blockForKeys函数前需要先看几个关于 block 的结构体和属性（省略部分属性）：
// 阻塞的几种类型 #define BLOCKED_NONE 0 /* Not blocked, no CLIENT_BLOCKED flag set. */#define BLOCKED_LIST 1 /* BLPOP &amp; co. */#define BLOCKED_WAIT 2 /* WAIT for synchronous replication. */#define BLOCKED_MODULE 3 /* Blocked by a loadable module. */#define BLOCKED_STREAM 4 /* XREAD. */#define BLOCKED_ZSET 5 /* BZPOP et al. */ // block info typedef struct bkinfo { listNode *listnode; /* List node for db-&gt;blocking_keys[key] list....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-26 23:48:25 +0800 HKT'>October 26, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：从bpop看block" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%BB%8Ebpop%E7%9C%8Bblock/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：一个命令的执行流程
    </h2>
  </header>
  <section class="entry-content">
    <p>一个命令的执行过程，我们大概可以分成三步骤：建立连接，发送命令，得到结果。下面会针对这三个命令，结合源码进行分析：
  建立连接
建立连接要从acceptTcpHandler这个函数说起。
前面说过，Redis 初始化服务时，会创建一个事件循环eventLoop。在 Redis 监听端口时，会给对应的 socket 绑定一个文件事件，且该事件的回调函数就是acceptTcpHandler。也就是说，任何连接到这个端口的客户端，Redis 都会调用acceptTcpHandler这个函数。
刚初始化后，等待客户端连接时的eventLoop（此处 fd 假设为 0）：
回调函数的整个调用链：acceptTcpHandler-&gt;acceptCommonHandler-&gt;createClient。
简单说明一下acceptTcpHandler的代码逻辑：Redis 最多会循环 1000 次accept客户端来得到对应的客户端 fd，并且每一次循环中会调用acceptCommonHandler函数。所以我们的目标转移到acceptCommonHandler函数上。
acceptCommonHandler的代码也很简单，最重要的是就是调用createClient函数，其余都是一些边界条件判断以及数据状态更新。
createClient做了什么？注册对应客户端 fd 的可读事件函数readQueryFromClient以及初始化client对象并且 push 到server的客户端链表里。
连接创建后的事件循环：
  发送命令
与客户端建立连接后，事件循环中就多了一个对应的文件描述符的读事件。只要客户端发送数据，在 Redis 进入到事件循环中就会调用对应事件的回调函数readQueryFromClient。
首先简述一下发送命令的调用链：readQueryFromClient-&gt;processInputBufferAndReplicate-&gt;processInputBuffer-&gt;processCommand-&gt;call。
  readQueryFromClient
这是 Redis 接受客户端请求后的回调函数，主要的逻辑就是读取 client 的 fd 的数据，并且存入 client 的 querybuf 变量中，然后调用processInputBufferAndReplicate。
  processInputBufferAndReplicate
因为客户端有可能用于主从节点，这一步其实就是对第三步的封装。主要是进行 client 类型的判断，如果是普通 client 就直接调用processInputBuffer。
  processInputBuffer
这一步是解析客户端的输入流中的 RESP 协议，转换成 Redis 中对应的参数，即 client 的 argv 变量。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-15 11:23:53 +0800 HKT'>October 15, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：一个命令的执行流程" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://rudychow.github.io/categories/redis/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
