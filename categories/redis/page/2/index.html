<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis | Rudy&#39;s blog</title>
<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/categories/redis/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.3" />
<link rel="alternate" type="application/rss+xml" href="https://rudychow.github.io/categories/redis/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Redis" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://rudychow.github.io/categories/redis/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>Redis</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：redisDB
    </h2>
  </header>
  <section class="entry-content">
    <p>redisDB 即是 database，是 Redis 的数据库。它是变量server里的一个成员变量数组，数组大小默认是 16。
客户端默认使用第一个数据库，其间可以使用select进行 db 的切换。
初始化 db 的初始化是在initServer中进行。
// 分配空间 server.db = zmalloc(sizeof(redisDb)*server.dbnum); // 遍历数组，并且初始化每个变量 for (j = 0; j &lt; server.dbnum; j&#43;&#43;) { server.db[j].dict = dictCreate(&amp;dbDictType,NULL); server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL); server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,NULL); server.db[j].ready_keys = dictCreate(&amp;objectKeyPointerValueDictType,NULL); server.db[j].watched_keys = dictCreate(&amp;keylistDictType,NULL); server.db[j].id = j; server.db[j].avg_ttl = 0; server.db[j].defrag_later = listCreate(); } 数据结构 对应的结构体如下：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-14 22:22:47 +0800 HKT'>October 14, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：redisDB" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81redisdb/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：入口函数main
    </h2>
  </header>
  <section class="entry-content">
    <p>main 函数是程序执行的起点，也是大家就阅读源码的入口。要了解 Redis 的初始化和运行过程，还是要通过 main 函数入手。
已一个单机的 Redis 为例，main 函数主要可以分成以下几个步骤：
  初始化配置
Redis 中有个非常重要的全局变量server，初始化配置就是针对这个变量进行的。
Redis 会先根据initServerConfig来进行默认配置的初始化。如果启动 server 时指定了配置文件，则会调用loadServerConfig来加载配置文件中的配置。
  初始化服务
initServer会进行一些服务的初始化，包括：信号捕获、创建共享对象、调整文件描述符限制、创建事件循环对象、初始化 db等等。
  初始化后台线程
通过InitServerLast函数进行，具体逻辑可以参考之前 bio 的文章。
  加载持久化数据
通过loadDataFromDisk函数进行数据加载，优先加载 AOF，如果没有开启 AOF 则加载 RDB。
  事件循环
通过aeMain来进行事件循环。
这个在之前的文件事件循环和时间事件循环中有提到过，没有提及两个前后置的函数：beforeSleep和afterSleep，这里进行一下补充
  beforeSleep
beforeSleep是在每次事件循环开始就会执行。
主要逻辑：
 集群的clusterBeforeSleep 进行一次过期 key 的快速清除 AOF 操作 注册可写的客户端的写事件  等等…
  afterSleep
需要注意的是，afterSleep的处理时机是在执行完aeApiPoll后，而不是处理完所有待处理的文件事件和时间事件后。
afterSleep主要涉及到 module，这部分代码尚未阅读。
    </p>
  </section>
  <footer class="entry-footer"><span title='2020-10-14 15:03:38 +0800 HKT'>October 14, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：入口函数main" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0main/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：bio
    </h2>
  </header>
  <section class="entry-content">
    <p>Redis 的主线程处理事件循环，所以我们常说 Redis 是单线程的（Redis6 之后加入了多线程模型）。但是在 Redis 中，也存在着 3 条线程，专门处理一些其它操作。
初始化 bio 的初始化在src/server.c中的InitServerLast函数，函数接着会调用src/bio.c的bioInit函数。
实现逻辑 与 bio 相关的几个宏定义、变量以及结构体：
// 后台线程的类型 #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */#define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */#define BIO_LAZY_FREE 2 /* Deferred objects freeing. */// 线程数量 #define BIO_NUM_OPS 3  // 线程数组 static pthread_t bio_threads[BIO_NUM_OPS]; // 线程锁数组 static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; // 线程条件变量数组 static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; // 任务数组 static list *bio_jobs[BIO_NUM_OPS]; // 待处理任务数组 static unsigned long long bio_pending[BIO_NUM_OPS]; // bio的每一个执行任务结构体 struct bio_job { time_t time; /* Time at which the job was created....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-12 16:39:29 +0800 HKT'>October 12, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：bio" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81bio/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：object
    </h2>
  </header>
  <section class="entry-content">
    <p>我们经常使用 Redis 的基础命令有string、set、list、hashtable和zset。在 Redis 的底层中，我们不是直接使用它们对应的数据结构，而是通过 object 对这些基础命令进行封装后再对外使用。
数据结构 typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; } robj;   type和encoding
type 是指对象记录的类型，分别对应着string、set、list、hashtable和zset。encoding 则表示编码，代表对应 type 的底层实现方式。
  ptr
这个是指向底层实现的数据结构的指针。
  refcount
引用计数，一个 object 可以被多个地方所使用。当被引用时，refcount 会 &#43;1，变成 0 时会被销毁。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-11 12:25:01 +0800 HKT'>October 11, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：object" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81object/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：skiplist
    </h2>
  </header>
  <section class="entry-content">
    <p>skiplist 是 Redis 对于跳跃表的一个实现，它也是 zset 的主要实现。网上关于 skiplist 数据结构的介绍有很多，这里主要记录 Redis 中的实现方式。
数据结构 // 跳表节点 typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[]; } zskiplistNode; // 跳表 typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length;// 有多少个节点  int level;// 目前有几层高 } zskiplist; skiplist 简单点说就是个有序的双向链表，同时为了提高查询复杂度，增加了层的概念，其实是一种空间换时间的方法。
与 adlist 这种传统的双向链表来比较，skiplist 的前节点指针跟 adlist 的*prev的用法一样，但是后节点的指针*next却不同。
skiplist 中指向后节点的指针是使用层来存储。层在代码中就是一个数组，在最底层level[0]中永远会指向下一个节点。如果只想把 skiplist 当作一个普通的双向链表来使用，那么通过 zskiplistNode 中的*backward以及level[0]....</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-08 12:13:32 +0800 HKT'>October 8, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：skiplist" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81skiplist/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：intset
    </h2>
  </header>
  <section class="entry-content">
    <p>intset 就是整数集合。这个集合只包含了整数，并且不回有重复数据。Redis 常用的 set 命令，当符合 intset 的情况时，底层就会使用 intset 去实现，其余情况则使用 dict。
数据结构 #define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t))  typedef struct intset { uint32_t encoding; uint32_t length; int8_t contents[]; } intset; intset 的结构体只有 3 个属性，比较简单：
  encoding
encoding 表示 intset 中存储的整数类型，这里只有三种选择：int16，int32 和 int64。
  length
length 表示集合个数。
  contents[]
实际存放的元素数组。这里虽然声明是 int8_t 类型，但实际存储的类型按照 encoding 来决定。即 encoding 是 int16，则 contents 存放的就是 int16 元素的数组。
  特点 intset 主要特点是存放元素是有序的，并且会对元素类型自动升级。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-08 10:46:35 +0800 HKT'>October 8, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：intset" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81intset/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：dict
    </h2>
  </header>
  <section class="entry-content">
    <p>dict 是 Redis 对于 hashtable 的表现，我们常用的 hash 命令底层就是通过 dict 实现的（严谨一点的话，一开始会使用 ziplist 作为实现，到一定阈值后才使用 dict）。
数据结构 // 字典 typedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict; // 字典的函数 typedef struct dictType { uint64_t (*hashFunction)(const void *key); void *(*keyDup)(void *privdata, const void *key); void *(*valDup)(void *privdata, const void *obj); int (*keyCompare)(void *privdata, const void *key1, const void *key2); void (*keyDestructor)(void *privdata, void *key); void (*valDestructor)(void *privdata, void *obj); } dictType; // hashtable结构体 typedef struct dictht { dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used; } dictht; // hashtable节点，存放key value typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry; hashtable Redis 主要使用dictht和dictEntry这两个结构体来实现基本的 hashtable，实现原理和常见的 hashtable 差不多。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-07 22:26:33 +0800 HKT'>October 7, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：dict" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81dict/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：quicklist
    </h2>
  </header>
  <section class="entry-content">
    <p>quicklist 全称是a generic doubly linked quicklist，从全称可以看得出这是一个节点存放 ziplist 的双向链表。我们常用的 list 功能，底层就是使用 quicklist 实现的。
数据结构 // 双向链表结构体 typedef struct quicklist { quicklistNode *head; quicklistNode *tail; unsigned long count; /* total count of all entries in all ziplists */ unsigned long len; /* number of quicklistNodes */ int fill : 16; /* fill factor for individual nodes */ unsigned int compress : 16; /* depth of end nodes not to compress;0=off */ } quicklist; // 节点 typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed?...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-07 15:34:26 +0800 HKT'>October 7, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：quicklist" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81quicklist/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：ziplist
    </h2>
  </header>
  <section class="entry-content">
    <p>ziplist，又称作压缩列表，它是 Redis 内部定义的连续的内存组成的数据结构，目的是减少内存碎片，节省内存空间。
数据结构 ziplist主要由三部分组成：header、entry和end。
header和end header 主要由三部分组成：
  bytes
bytes 记录整个 ziplist 占用的内存字节数，长度是 4 个字节。
  tail
tail 就是最后一个节点到 ziplist 起始位置的偏移量，该偏移量是从 ziplist 指针开始计算。
  len
ziplist 的节点数。当 len &lt; 65535 时，len 即是节点数，此时取 ziplist 的节点数的复杂度是 O(1)。当 len = 65535 时，需要遍历整个节点获取实际的 len，此时取 ziplist 的节点数的复杂度是 O(n)。
  end 是一个恒定值 0xff，用来标识 ziplist 的末尾。
entry entry 是 ziplist 中的每一个节点，也是由三个部分组成：prevlen、encoding和content。下面是 entry 的大概结构：
  prevlen
这是 entry 的第一部分，这个部分定义了前一个元素的长度。并且它的内存占用大小是不定的，有可能是 1 字节，有可能是 5 字节。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-06 18:40:41 +0800 HKT'>October 6, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：ziplist" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81ziplist/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Redis源码：adlist
    </h2>
  </header>
  <section class="entry-content">
    <p>adlist 全称是a generic doubly linked list，是 Redis 内部实现的一个双向链表。旧版本中，list 是使用 adlist 实现的，后面的版本改成用 quicklist 实现。
数据结构 // 链表节点 typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; // 链表 typedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; adlist 是一个常见的双向链表。它比一般的双向链表多记录了链表的长度，所以 adlist 获取元素个数的复杂度是 O(1)，以及几个触发函数：赋值、释放空间和匹配，它会在调用listDup、listEmpty以及listSearchKey时调用对应函数。
此外，adlist 还实现了自己的迭代器：
#define AL_START_HEAD 0 #define AL_START_TAIL 1 // 迭代器 typedef struct listIter { listNode *next; int direction; } listIter; 该迭代器根据 direction 的值可以从头到尾或者从尾到头进行遍历。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-05 15:45:16 +0800 HKT'>October 5, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Redis源码：adlist" href="https://rudychow.github.io/post/redis/redis%E6%BA%90%E7%A0%81adlist/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://rudychow.github.io/categories/redis/">« Prev Page</a>
    <a class="next" href="https://rudychow.github.io/categories/redis/page/3/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
