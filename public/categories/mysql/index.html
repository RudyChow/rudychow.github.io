<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL | Rudy&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Rudy">
<link rel="canonical" href="https://rudychow.github.io/categories/mysql/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rudychow.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rudychow.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rudychow.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rudychow.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rudychow.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://rudychow.github.io/categories/mysql/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="MySQL" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://rudychow.github.io/categories/mysql/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rudychow.github.io/" accesskey="h" title="Rudy&#39;s blog (Alt + H)">Rudy&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rudychow.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://rudychow.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/RudyChow" title="github">
                    <span>github</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    MySQL
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>查询语句的访问方式
    </h2>
  </header>
  <div class="entry-content">
    <p>简单总结一下 MySQL 表的访问方式：
等值
const：
最多只能有一个匹配记录，这个方式应用在聚簇索引或唯一索引上。
eq_ref：
和 const 差不多的性能，不过用在连表上。当连接的表的条件是聚簇索引或者唯一索引（不为 null）时，会使用 eq_ref。
ref：
通过等值条件，可能匹配到多行数据，普通索引常用。当唯一索引可以为 null 时，cond is null由于可以匹配到多行数据，所以也是使用 ref。
ref_or_null：
匹配到多行数据，包括 null 时。cond = xx or cond is null这种条件，就会使用 ref_or_null。
范围
range：
=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, or IN() 时会使用的方式
子查询
unique_subquery：
聚簇索引或者唯一索引的情况下，IN 的子查询会使用 unique_subquery，如value IN (SELECT primary_key FROM single_table WHERE some_expr)。
index_subquery：
和 unique_subquery 差不多，不过作用于普通索引上，如value IN (SELECT key_column FROM single_table WHERE some_expr)。
其它...</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-05 23:38:36 +0800 CST'>January 5, 2021</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 查询语句的访问方式" href="https://rudychow.github.io/post/mysql/%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Join算法
    </h2>
  </header>
  <div class="entry-content">
    <p>MySQL 目前主要的 join 算法有两类：Hash Join 和 Nested-Loop Join。
Hash Join Hash Join 是 MySQL 在 8.0.18 后支持的连表算法，这个时候的 Hash Join 有两个阶段：
build
构建阶段下，MySQL 会将小的表作为构建，构建的 HashTable 以连接条件为 key，行数据为 value。一旦所有的数据都存储在 HashTable 中，就完成了构建阶段。
当构建阶段中，如果内存中的 HashTable 被用完，则其余数据会溢出到缓存块中，并以另一个 hash 算法去决定写入哪个缓存块。内存中的 HashTable 由变量join_buffer_size控制。
probe
探测阶段下，MySQL 从另一个表中读取每一行。对于每一行，都会使用连接条件的值作为查找键去查看 HashTable 是否有匹配的数据。对于每一个匹配项，就向客户端发送一个合并行。
如果 build 阶段溢出了，那么 probe 阶段下也会把循环的每一行写入缓存块。由于写入缓冲块和 build 阶段时用的是同一个 hash 算法，所以他们的缓存块号是一致的。当内存的 HashTable 已经匹配完，依次加载每一个对应的 build 和 probe 的缓存块进内存，再重新执行 probe 逻辑即可。
在这个版本中，Hash Join 有几个限制条件：
只能用在没有索引的等值的连接条件 只能用在内连，即不支持left join、right join、semijoin和antijoin。 但是在 8.0.20 后的版本，已经没有了这两个限制。（但在这个版本下，non-equi-join下如何进行 build 和 probe，我还没弄清楚）...</p>
  </div>
  <footer class="entry-footer"><span title='2021-01-03 23:42:34 +0800 CST'>January 3, 2021</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to Join算法" href="https://rudychow.github.io/post/mysql/join%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>事务
    </h2>
  </header>
  <div class="entry-content">
    <p>事务是数据库区别于文件系统的重要特性之一。数据库系统引入事务的主要目的：事务会把数据库从一种一致状态转移为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。
特性 InnoDB 存储引擎中的事务完全符合 ACID 的特性，ACID 是以下 4 个词的缩写
原子性（atomicity）
原子性指整个数据库事务是不可分割的工作单位，只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个 SQL 语句执行失败，已经执行成功的 SQL 语句也必须撤销，数据库状态应该退回到执行事务前的状态。
一致性（consistency）
一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
隔离性（isolation）
隔离性还有其它称呼，如并发控制、可串行化、锁等等。事务的隔离性要求每个读写事务的对象对其它事务的操作对象能互相分离，即该事务提交前对其它事务都不可见，通常这使用锁来实现。
持久性（durability）
事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。事务只能从本身角度来保证结果的永久性，但如果不是数据库本身发生故障，而是一些外部原因，如 RAID 卡损坏、自然灾害等原因导致数据库发生问题，那么所有提交数据可能都会丢失。因此持久性保证事务系统的高可靠性，而不是高可用性。
事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的 redo log 和 undo log 来完成。redo log 称为重做日志，用来保证事务的原子性和持久性。undo log 用来保证事务的一致性。
隔离级别 ISO 和 ANIS SQL 标准制定了四种事务隔离级别的标准，分别是：
READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 事务并发执行时可能遇到的问题：
脏读：一个事务读到了另一个未提交事务修改过的数据。 不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。 幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED Possible Possible Possible READ COMMITTED Not Possible Possible Possible REPEATABLE READ Not Possible Not Possible Possible SERIALIZABLE Not Possible Not Possible Not Possible InnoDB 存储引擎默认支持的隔离级别是REPEATABLE READ，但是与标准 SQL 不同的是，InnoDB 存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法，避免了幻读的产生。所以说，InnoDB 存储引擎在默认的REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SERIALIZABLE隔离级别。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-28 22:58:32 +0800 CST'>December 28, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 事务" href="https://rudychow.github.io/post/mysql/%E4%BA%8B%E5%8A%A1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>undo日志
    </h2>
  </header>
  <div class="entry-content">
    <p>undo log 主要有两个作用：事务回滚和 MVCC。
到底是什么是 undo log ？前面说到 InnoDB 表空间存放着许多不同类型的页，undo log 就是其中的一种类型。它和 redo log 不同，是一种逻辑日志，记录着数据之前的样子。又因为 undo log 是表空间的一种页，所以在产生 undo log 之前，也会产生对应的 redo log。
类型 undo log 分为 insert undo log 和 update undo log。
insert undo log 是指在 insert 操作中产生的 undo log。因为 insert 操作的记录，指对事务本身可见，对其它事务不可见（事务隔离性），所以这种 undo log 可以在事务提交后直接删除，不需要进行 purge 操作。
update undo log 记录的是 delete 和 update 操作产生的 undo log。该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。
回滚指针 从数据页中的数据行的格式了解 undo log：...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-13 21:33:54 +0800 CST'>December 13, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to undo日志" href="https://rudychow.github.io/post/mysql/undo%E6%97%A5%E5%BF%97/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>B&#43;树查询
    </h2>
  </header>
  <div class="entry-content">
    <p>B&#43; 树是一种多路平衡树，通过 B 树演化而来。
我们知道从一组有序数字数组中查找目标记录，使用二分查找法（Binary Search）是一种有效的方式，复杂度达到 O(log2n)。但是如果要在几个分开的有序数组中找到目标记录，要怎样才比较有效率？
假设有 4 个数组，每个数组最多只能存放 4 个元素，现在需要在这四个数组中找到目标 10：
page1 := []int{1, 2, 3, 4} page2 := []int{5, 6, 7, 8} page3 := []int{9, 10, 11, 12} page4 := []int{13, 14, 15, 16} 第一个想法是把所有数组合并起来，再进行二分查找，这样复杂度还是 O(log2n)。上面代码中每一个数组，在 MySQL 中其实是一个页，也是 InnoDB 存放在磁盘上的最小单位。如果在 MySQL 中要把所有页的数据合并在一起，再进行二分查找，那么当数据页非常多的时候，内存会非常吃紧，所以这不算是一个好的方案。
换一个想法，现在从每个数组中取出一个最小数，作为当前数组的代表，此时可以抽取出 1、5、9、13。因为每个数组是有序的，所以这几个代表，可以表示一个区间：1 表示 [1,5) 的区间，5 表示 [5,9) 的区间，9 表示 [9,13) 的区间，13 表示 [13,&#43;∞) 的区间。所以在这 4 个数字中，你仍可以使用二分查找的方式，虽然这里面没有 10 这个数，但是可以得知 10 是属于 9 这个代表的，因为 10 属于 [9,13) 这个区间。最后，通过 9 这个代表，找到page3这个数组，并且在里面通过二分查找的方式找到 10 即可。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-13 17:53:23 +0800 CST'>December 13, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to B&#43;树查询" href="https://rudychow.github.io/post/mysql/b&#43;%E6%A0%91%E6%9F%A5%E8%AF%A2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>InnoDB存储结构
    </h2>
  </header>
  <div class="entry-content">
    <p>从 InnoDB 存储引擎的逻辑存储结构看，所有数据都被逻辑地存在一个空间中，称为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。
这一部分内容基本都是讲存储结构的，所以用自己语言简单总结一下，避免以后看不懂。
表空间是什么？
InnoDB 相关的数据总得有个地方存。表空间说白了就是存储 InnoDB 相关的文件，包括且不限于数据、索引、undo信息。
默认有一个共享表空间，即ibdata1。如果开启了参数innodb_file_per_table，则每个表会有自己独立的存储文件，文件是表名.ibd。
页是什么？
说到 MySQL 一定会谈到 B&#43; 树，谈到 B&#43; 树又一定会谈到页。页说白了就是一个连续的空间，默认是 16KB。
我们知道数据是存储在页里面，所以这个页叫数据页。页是 InnoDB 操作数据的最小单位，它不单指只有数据页这种类型，还有许多其它类型：
B&#43; 树叶节点 undo log 页 索引节点 新分配未使用 系统页 Insert Buffer Bitmap … 而在表空间里，其实就是由许许多多的页构成，从代码上看大概是这样：
type page struct{} func main() { // 表空间里面有许许多多页组成 // 每个表空间一定会有三个页 // 系统表空间也会预先分配一定的空间 tablespace := make([]page, 3, 64) // 第一个页是系统页 fmt.Println(tablespace[0]) // 第二个页是insert buffer bitmap页 fmt.Println(tablespace[1]) // 第三个页是段索引页 fmt.Println(tablespace[2]) } 区是什么？
其实光有表空间和页，InnoDB 完成也可以运作，但是在页的管理上会比较麻烦，而且在数据读取上容易产生随机 IO，所以就引申出区的概念。
默认的页是 16KB，而连续的 64 个页就可以组成一个区，所以区具有空间连续性。当然页的大小可以调整，但是无论页怎么调整，区的大小永远固定是 1MB。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-08 23:09:35 +0800 CST'>December 8, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to InnoDB存储结构" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>redo日志
    </h2>
  </header>
  <div class="entry-content">
    <p>结合最近的学习总结一下 redo log 相关的知识，以及回答之前的困惑。
redo log 与 bin log 这两个日志是我之前经常迷惑的地方，因为两者在不同层面上都能实现恢复数据的效果。
要了解两者的区别，首先要知道这两个日志分别是什么。
redo log 是基于 InnoDB 存储引擎的一个日志，它是用来保证数据持久性的一个日志，并且记录的是物理日志，例如一个 DML 的 SQL 语句导致表空间的某几个页的某个位置。除此之外，redo log 的日志并不会长期保存，而是会进行循环覆盖，这个跟 Checkpoint 机制有关。
bin log 是 MySQL Server 层面的一个日志，意思是不管什么存储引擎，MySQL 都可以进行 bin log 的日志。bin log 默认不开启，并且记录的是逻辑日志，即具体的 SQL 语句（ROW和MIXED格式的则不一定）。bin log 的日志会不停增长，它常常用于复制数据。
那么 redo log 和 bin log 是怎么保持两边数据的一致性呢？两边是通过两阶段提交（2PC）来解决两个日志之间数据不一致的问题。通过配置参数innodb_support_xa来开启 XA 事务。MySQL 8 之后废弃了该参数，默认开启 XA。
流程是：
当事务提交时 InnoDB 存储引擎进行 prepare 操作。 MySQL 数据库上层写入 bin log。 InnoDB 存储引擎将日志写入 redo log。 修改内存中事务对应的信息，并且将日志写入 redo buffer cache。 调用 fsync 将确保日志都从 redo buffer cache 写入磁盘。 在做 Carash Recovery 时：...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-06 11:57:57 +0800 CST'>December 6, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to redo日志" href="https://rudychow.github.io/post/mysql/redo%E6%97%A5%E5%BF%97/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：文件
    </h2>
  </header>
  <div class="entry-content">
    <p>这一章节重点在 bin log 以及 InnoDB 存储引擎文件。
参数文件 MySQL 实例启动时，会先读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，用户可以通过怕命令mysql --help| grep my.cnf来寻找即可。
MySQL 实例可以不需要参数文件，这时所有的参数值取决于编译 MySQL 时指定的默认值和源代码中指定参数的默认值。推荐使用命令SHOW VARIABLES来查看数据库中的所有参数，也可以通过 LIKE 来过滤参数名。
参数可以分成两类：动态参数和静态参数。
动态参数意味着可以在 MySQL 实例运行中进行更改，静态参数说明在整个实例生命周期内都不得进行更改。
可以通过 SET 命令对动态参数值修改，语法：SET [global | session] system_var_name = expr。
global 和 session 表明参数修改是基于当前会话还是整个实例。有些动态参数只能在会话中进行修改，如autocommit；而有些参数修改完后，在整个实例生命周期都会生效，如binlog_cache_size；而有些参数既可以在会话中也可以在实例中生效，如read_buffer_size。
日志文件 错误日志 错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令SHOW VARIABLES LIKE &#39;log_error&#39;来定位该文件。
慢查询日志 慢日志可以帮助 DBA 定位可能存在问题的 SQL 语句，从而进行 SQL 语句层面的优化。可以通过参数log_query_time（单位微秒）来设置慢查询日志的阈值。
另一个和慢查询日志有关的参数是log_queries_not_using_indexes，如果运行的 SQL 语句没有使用索引，MySQL 数据库同样会将这条 SQL 语句记录到慢查询日志文件。
MySQL 5.6.5 版本开始新增了一个参数log_throttle_queries_not_using_indexes，用来表示每分钟允许记录到 slow log 的且未使用索引的 SQL 语句次数。该值默认为 0，表示没有限制。
MySQL 数据库提供了mysqldumpslow命令，可以帮助 DBA 更直观分析 slow log。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-05 19:04:43 +0800 CST'>December 5, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：文件" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：InnoDB存储引擎
    </h2>
  </header>
  <div class="entry-content">
    <p>这一章节随便拿出一小节都可以单独写一篇文章，这里仅做笔记和总结。
体系架构 后台线程 InnoDB 存储引擎是多线程的模型，因此后台有多个不同的后台线程，负责处理不同的任务。
Master Thread Master Thread 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO 页的回收等。
IO Thread 在 InnoDB 存储引擎中大量使用了 AIO 来处理写 IO 请求，这样可以极大提高数据库的性能，IO Thread 的工作主要是负责这些 IO 请求的回调处理。
InnoDB 1.0 版本之前共有 4 个 IO Thread，分别是 write、read、insert buffer 和 log IO thread。
Purge Thread 事务被提交后，所使用的 undolog 可能不再需要，因此需要 Purge Thread 来回收已经使用并分配的 undo 页。在 InnoDB 1.1 版本之前，purge 操作仅在 Master Thread 中完成。而在 InnoDB 1.1 版本开始，purge 操作可以独立到单独的线程中进行，以此来减轻 Master Thread 的工作，从而提高 CPU 的利用率以及提升存储引擎的性能。
用可可以在 MySQL 数据库的配置文件中添加如下命令来启用独立的 Pruge Thread：
[mysqld] innodb_purge_threads=1 Page Cleaner Thread Page Cleaner Thread 实在 InnoDB 1....</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-04 22:23:00 +0800 CST'>December 4, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：InnoDB存储引擎" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>《InnoDB存储引擎》笔记：MySQL体系结构和存储引擎
    </h2>
  </header>
  <div class="entry-content">
    <p>这一节主要是一些基础概念和介绍，所以此处只进行了基本的笔记总结。
数据库与实例 数据库：物理操作系统文件或其他形式文件类型的集合。
实例：MySQL 数据库由后台线程以及一个共享内存区组成。MySQL 数据库实例在系统上的表现就是一个进程。
配置 当启动实例时，MySQL 数据库会按/etc/my.cnf-&gt;/etc/mysql/my.cnf-&gt;/usr/local/mysql/etc/my.cnf-&gt;~/.my.cnf去读取配置文件，并且以读取到的最后一个配置文件中的参数为准。
配置文件中有一个参数datadir，该参数指定了数据库所在的路径。在 Linux 操作系统下默认datadir为/usr/local/mysql/data。
连接方式 TCP/IP 命名管道 UNIX 域套接字 存储引擎 MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。需要注意，存储引擎基于表，而不是数据库。
MyISAM MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP 数据库应用。MyISAM 存储引擎有两个与众不同的地方：
不支持事务，因为并非所有的应用中都需要事务。 它的缓冲池只缓存索引文件，而不缓冲数据文件。 MyISAM 存储引擎表由 MYD 和 MYI 组成，MYD 用来存放数据文件，MYI 用来存放索引文件。
Memory Memory 存储引擎将表中的数据存放在内存中，如果数据库重启或者发生崩溃，表中的数据都将消失。Memory 存储引擎默认使用哈希索引，而不是我们熟悉的 B&#43;树索引。
Memory 存储引擎在使用上有一定限制，比如，只支持表锁，并发性能较差，并且不支持 TEXT 和 BLOB 列类型。MySQL 数据库使用 Memory 存储引擎作为临时表来存放查询的中间结果集。如果中间结果集大于 Memory 存储引擎的容量设置，又或者中间结果含有 TEXT 或 BLOB 列类型字段，则 MySQL 数据库会把其转换到 MyISAM 存储引擎表而存放到磁盘中。之前提到 MyISAM 不缓存数据文件，因为这时产生的临时表的性能对于查询会有损失。
InnoDB InnoDB 存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于 Oracle 的非锁定读，即默认读取操作不会产生锁。从 MySQL 数据库 5.5.8 版本开始，InnoDB 存储引擎是默认的存储引擎。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-12-04 18:02:36 +0800 CST'>December 4, 2020</span>&nbsp;·&nbsp;Rudy</footer>
  <a class="entry-link" aria-label="post link to 《InnoDB存储引擎》笔记：MySQL体系结构和存储引擎" href="https://rudychow.github.io/post/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://rudychow.github.io/categories/mysql/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rudychow.github.io/">Rudy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
